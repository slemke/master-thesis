private static Class < ? extends Date > verifyDateType ( Class < ? extends Date > dateType ) { if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) { throw new IllegalArgumentException ( " Date type must be one of " + Date.class + " , " + Timestamp.class + " , or " + java.sql.Date.class + " but was " + dateType ) ; } return dateType ; }
public void write ( JsonWriter out , Date value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; return ; } synchronized ( dateFormats ) { String dateFormatAsString = dateFormats.get ( 0 ) .format ( value ) ; out.value ( dateFormatAsString ) ; } }
public Class < ? > getDeclaringClass ( ) { return field.getDeclaringClass ( ) ; }
public String getName ( ) { return field.getName ( ) ; }
public Type getDeclaredType ( ) { return field.getGenericType ( ) ; }
public Class < ? > getDeclaredClass ( ) { return field.getType ( ) ; }
public < T extends Annotation > T getAnnotation ( Class < T > annotation ) { return field.getAnnotation ( annotation ) ; }
public Collection < Annotation > getAnnotations ( ) { return Arrays.asList ( field.getAnnotations ( ) ) ; }
public boolean hasModifier ( int modifier ) { return ( field.getModifiers ( ) & modifier ) != 0 ; }
Object get ( Object instance ) throws IllegalAccessException { return field.get ( instance ) ; }
boolean isSynthetic ( ) { return field.isSynthetic ( ) ; }
static String separateCamelCase ( String name , String separator ) { StringBuilder translation = new StringBuilder ( ) ; for ( int i = 0 , length = name.length ( ) ; i < length ; i++ ) { char character = name.charAt ( i ) ; if ( Character.isUpperCase ( character ) && translation.length ( ) != 0 ) { translation.append ( separator ) ; } translation.append ( character ) ; } return translation.toString ( ) ; }
private static String modifyString ( char firstCharacter , String srcString , int indexOfSubstring ) { return ( indexOfSubstring < srcString.length ( ) ) ? firstCharacter + srcString.substring ( indexOfSubstring ) : String.valueOf ( firstCharacter ) ; }
public String translateName ( Field f ) { return f.getName ( ) ; }
public String translateName ( Field f ) { return upperCaseFirstLetter ( f.getName ( ) ) ; }
public String translateName ( Field f ) { return upperCaseFirstLetter ( separateCamelCase ( f.getName ( ) , " " ) ) ; }
public String translateName ( Field f ) { return separateCamelCase ( f.getName ( ) , " _ " ) .toLowerCase ( Locale.ENGLISH ) ; }
public String translateName ( Field f ) { return separateCamelCase ( f.getName ( ) , " - " ) .toLowerCase ( Locale.ENGLISH ) ; }
public String translateName ( Field f ) { return separateCamelCase ( f.getName ( ) , " . " ) .toLowerCase ( Locale.ENGLISH ) ; }
public GsonBuilder newBuilder ( ) { return new GsonBuilder ( this ) ; }
public Excluder excluder ( ) { return excluder ; }
public FieldNamingStrategy fieldNamingStrategy ( ) { return fieldNamingStrategy ; }
public boolean serializeNulls ( ) { return serializeNulls ; }
public boolean htmlSafe ( ) { return htmlSafe ; }
public void write ( JsonWriter out , Number value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; return ; } double doubleValue = value.doubleValue ( ) ; checkValidFloatingPoint ( doubleValue ) ; out.value ( value ) ; }
public void write ( JsonWriter out , Number value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; return ; } float floatValue = value.floatValue ( ) ; checkValidFloatingPoint ( floatValue ) ; out.value ( value ) ; }
static void checkValidFloatingPoint ( double value ) { if ( Double.isNaN ( value ) || Double.isInfinite ( value ) ) { throw new IllegalArgumentException ( value + " is not a valid double value as per JSON specification. To override this " + " behavior , use GsonBuilder.serializeSpecialFloatingPointValues ( ) method. " ) ; } }
public void write ( JsonWriter out , Number value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; return ; } out.value ( value.toString ( ) ) ; }
public void write ( JsonWriter out , AtomicLong value ) throws IOException { longAdapter.write ( out , value.get ( ) ) ; }
public AtomicLong read ( JsonReader in ) throws IOException { Number value = longAdapter.read ( in ) ; return new AtomicLong ( value.longValue ( ) ) ; }
public void write ( JsonWriter out , AtomicLongArray value ) throws IOException { out.beginArray ( ) ; for ( int i = 0 , length = value.length ( ) ; i < length ; i++ ) { longAdapter.write ( out , value.get ( i ) ) ; } out.endArray ( ) ; }
public AtomicLongArray read ( JsonReader in ) throws IOException { List < Long > list = new ArrayList < Long > ( ) ; in.beginArray ( ) ; while ( in.hasNext ( ) ) { long value = longAdapter.read ( in ) .longValue ( ) ; list.add ( value ) ; } in.endArray ( ) ; int length = list.size ( ) ; AtomicLongArray array = new AtomicLongArray ( length ) ; for ( int i = 0 ; i < length ; ++i ) { array.set ( i , list.get ( i ) ) ; } return array ; }
public < T > TypeAdapter < T > getAdapter ( Class < T > type ) { return getAdapter ( TypeToken.get ( type ) ) ; }
public JsonElement toJsonTree ( Object src ) { if ( src == null ) { return JsonNull.INSTANCE ; } return toJsonTree ( src , src.getClass ( ) ) ; }
public JsonElement toJsonTree ( Object src , Type typeOfSrc ) { JsonTreeWriter writer = new JsonTreeWriter ( ) ; toJson ( src , typeOfSrc , writer ) ; return writer.get ( ) ; }
public String toJson ( Object src ) { if ( src == null ) { return toJson ( JsonNull.INSTANCE ) ; } return toJson ( src , src.getClass ( ) ) ; }
public String toJson ( Object src , Type typeOfSrc ) { StringWriter writer = new StringWriter ( ) ; toJson ( src , typeOfSrc , writer ) ; return writer.toString ( ) ; }
public void toJson ( Object src , Appendable writer ) throws JsonIOException { if ( src != null ) { toJson ( src , src.getClass ( ) , writer ) ; } else { toJson ( JsonNull.INSTANCE , writer ) ; } }
public void toJson ( Object src , Type typeOfSrc , Appendable writer ) throws JsonIOException { try { JsonWriter jsonWriter = newJsonWriter ( Streams.writerForAppendable ( writer ) ) ; toJson ( src , typeOfSrc , jsonWriter ) ; } catch ( IOException e ) { throw new JsonIOException ( e ) ; } }
public String toJson ( JsonElement jsonElement ) { StringWriter writer = new StringWriter ( ) ; toJson ( jsonElement , writer ) ; return writer.toString ( ) ; }
public void toJson ( JsonElement jsonElement , Appendable writer ) throws JsonIOException { try { JsonWriter jsonWriter = newJsonWriter ( Streams.writerForAppendable ( writer ) ) ; toJson ( jsonElement , jsonWriter ) ; } catch ( IOException e ) { throw new JsonIOException ( e ) ; } }
public JsonWriter newJsonWriter ( Writer writer ) throws IOException { if ( generateNonExecutableJson ) { writer.write ( JSON_NON_EXECUTABLE_PREFIX ) ; } JsonWriter jsonWriter = new JsonWriter ( writer ) ; if ( prettyPrinting ) { jsonWriter.setIndent ( " " ) ; } jsonWriter.setSerializeNulls ( serializeNulls ) ; return jsonWriter ; }
public JsonReader newJsonReader ( Reader reader ) { JsonReader jsonReader = new JsonReader ( reader ) ; jsonReader.setLenient ( lenient ) ; return jsonReader ; }
public < T > T fromJson ( String json , Class < T > classOfT ) throws JsonSyntaxException { Object object = fromJson ( json , ( Type ) classOfT ) ; return Primitives.wrap ( classOfT ) .cast ( object ) ; }
public < T > T fromJson ( Reader json , Class < T > classOfT ) throws JsonSyntaxException , JsonIOException { JsonReader jsonReader = newJsonReader ( json ) ; Object object = fromJson ( jsonReader , classOfT ) ; assertFullConsumption ( object , jsonReader ) ; return Primitives.wrap ( classOfT ) .cast ( object ) ; }
public < T > T fromJson ( Reader json , Type typeOfT ) throws JsonIOException , JsonSyntaxException { JsonReader jsonReader = newJsonReader ( json ) ; T object = ( T ) fromJson ( jsonReader , typeOfT ) ; assertFullConsumption ( object , jsonReader ) ; return object ; }
private static void assertFullConsumption ( Object obj , JsonReader reader ) { try { if ( obj != null && reader.peek ( ) != JsonToken.END_DOCUMENT ) { throw new JsonIOException ( " JSON document was not fully consumed. " ) ; } } catch ( MalformedJsonException e ) { throw new JsonSyntaxException ( e ) ; } catch ( IOException e ) { throw new JsonIOException ( e ) ; } }
public < T > T fromJson ( JsonElement json , Class < T > classOfT ) throws JsonSyntaxException { Object object = fromJson ( json , ( Type ) classOfT ) ; return Primitives.wrap ( classOfT ) .cast ( object ) ; }
public void setDelegate ( TypeAdapter < T > typeAdapter ) { if ( delegate != null ) { throw new AssertionError ( ) ; } delegate = typeAdapter ; }
public T read ( JsonReader in ) throws IOException { if ( delegate == null ) { throw new IllegalStateException ( ) ; } return delegate.read ( in ) ; }
public void write ( JsonWriter out , T value ) throws IOException { if ( delegate == null ) { throw new IllegalStateException ( ) ; } delegate.write ( out , value ) ; }
public GsonBuilder setVersion ( double ignoreVersionsAfter ) { excluder = excluder.withVersion ( ignoreVersionsAfter ) ; return this ; }
public GsonBuilder excludeFieldsWithModifiers ( int... modifiers ) { excluder = excluder.withModifiers ( modifiers ) ; return this ; }
public GsonBuilder generateNonExecutableJson ( ) { this.generateNonExecutableJson = true ; return this ; }
public GsonBuilder excludeFieldsWithoutExposeAnnotation ( ) { excluder = excluder.excludeFieldsWithoutExposeAnnotation ( ) ; return this ; }
public GsonBuilder serializeNulls ( ) { this.serializeNulls = true ; return this ; }
public GsonBuilder enableComplexMapKeySerialization ( ) { complexMapKeySerialization = true ; return this ; }
public GsonBuilder disableInnerClassSerialization ( ) { excluder = excluder.disableInnerClassSerialization ( ) ; return this ; }
public GsonBuilder setLongSerializationPolicy ( LongSerializationPolicy serializationPolicy ) { this.longSerializationPolicy = serializationPolicy ; return this ; }
public GsonBuilder setFieldNamingPolicy ( FieldNamingPolicy namingConvention ) { this.fieldNamingPolicy = namingConvention ; return this ; }
public GsonBuilder setFieldNamingStrategy ( FieldNamingStrategy fieldNamingStrategy ) { this.fieldNamingPolicy = fieldNamingStrategy ; return this ; }
public GsonBuilder setExclusionStrategies ( ExclusionStrategy... strategies ) { for ( ExclusionStrategy strategy : strategies ) { excluder = excluder.withExclusionStrategy ( strategy , true , true ) ; } return this ; }
public GsonBuilder addSerializationExclusionStrategy ( ExclusionStrategy strategy ) { excluder = excluder.withExclusionStrategy ( strategy , true , false ) ; return this ; }
public GsonBuilder addDeserializationExclusionStrategy ( ExclusionStrategy strategy ) { excluder = excluder.withExclusionStrategy ( strategy , false , true ) ; return this ; }
public GsonBuilder setPrettyPrinting ( ) { prettyPrinting = true ; return this ; }
public GsonBuilder setLenient ( ) { lenient = true ; return this ; }
public GsonBuilder disableHtmlEscaping ( ) { this.escapeHtmlChars = false ; return this ; }
public GsonBuilder setDateFormat ( String pattern ) { this.datePattern = pattern ; return this ; }
public GsonBuilder setDateFormat ( int style ) { this.dateStyle = style ; this.datePattern = null ; return this ; }
public GsonBuilder setDateFormat ( int dateStyle , int timeStyle ) { this.dateStyle = dateStyle ; this.timeStyle = timeStyle ; this.datePattern = null ; return this ; }
public GsonBuilder registerTypeAdapterFactory ( TypeAdapterFactory factory ) { factories.add ( factory ) ; return this ; }
public GsonBuilder serializeSpecialFloatingPointValues ( ) { this.serializeSpecialFloatingPointValues = true ; return this ; }
public Gson create ( ) { List < TypeAdapterFactory > factories = new ArrayList < TypeAdapterFactory > ( this.factories.size ( ) + this.hierarchyFactories.size ( ) + 3 ) ; factories.addAll ( this.factories ) ; Collections.reverse ( factories ) ; List < TypeAdapterFactory > hierarchyFactories = new ArrayList < TypeAdapterFactory > ( this.hierarchyFactories ) ; Collections.reverse ( hierarchyFactories ) ; factories.addAll ( hierarchyFactories ) ; addTypeAdaptersForDate ( datePattern , dateStyle , timeStyle , factories ) ; return new Gson ( excluder , fieldNamingPolicy , instanceCreators , serializeNulls , complexMapKeySerialization , generateNonExecutableJson , escapeHtmlChars , prettyPrinting , lenient , serializeSpecialFloatingPointValues , longSerializationPolicy , datePattern , dateStyle , timeStyle , this.factories , this.hierarchyFactories , factories ) ; }
public static < T > T checkNotNull ( T obj ) { if ( obj == null ) { throw new NullPointerException ( ) ; } return obj ; }
public static void checkArgument ( boolean condition ) { if ( !condition ) { throw new IllegalArgumentException ( ) ; } }
public static ParameterizedType newParameterizedTypeWithOwner ( Type ownerType , Type rawType , Type... typeArguments ) { return new ParameterizedTypeImpl ( ownerType , rawType , typeArguments ) ; }
public static GenericArrayType arrayOf ( Type componentType ) { return new GenericArrayTypeImpl ( componentType ) ; }
public static WildcardType subtypeOf ( Type bound ) { Type[] upperBounds ; if ( bound instanceof WildcardType ) { upperBounds = ( ( WildcardType ) bound ) .getUpperBounds ( ) ; } else { upperBounds = new Type[] { bound } ; } return new WildcardTypeImpl ( upperBounds , EMPTY_TYPE_ARRAY ) ; }
public static WildcardType supertypeOf ( Type bound ) { Type[] lowerBounds ; if ( bound instanceof WildcardType ) { lowerBounds = ( ( WildcardType ) bound ) .getLowerBounds ( ) ; } else { lowerBounds = new Type[] { bound } ; } return new WildcardTypeImpl ( new Type[] { Object.class } , lowerBounds ) ; }
static int hashCodeOrZero ( Object o ) { return o != null ? o.hashCode ( ) : 0 ; }
public static String typeToString ( Type type ) { return type instanceof Class ? ( ( Class < ? > ) type ) .getName ( ) : type.toString ( ) ; }
static Type getSupertype ( Type context , Class < ? > contextRawType , Class < ? > supertype ) { if ( context instanceof WildcardType ) { context = ( ( WildcardType ) context ) .getUpperBounds ( ) [0] ; } checkArgument ( supertype.isAssignableFrom ( contextRawType ) ) ; return resolve ( context , contextRawType , $Gson$Types.getGenericSupertype ( context , contextRawType , supertype ) ) ; }
public static Type getArrayComponentType ( Type array ) { return array instanceof GenericArrayType ? ( ( GenericArrayType ) array ) .getGenericComponentType ( ) : ( ( Class < ? > ) array ) .getComponentType ( ) ; }
public static Type getCollectionElementType ( Type context , Class < ? > contextRawType ) { Type collectionType = getSupertype ( context , contextRawType , Collection.class ) ; if ( collectionType instanceof WildcardType ) { collectionType = ( ( WildcardType ) collectionType ) .getUpperBounds ( ) [0] ; } if ( collectionType instanceof ParameterizedType ) { return ( ( ParameterizedType ) collectionType ) .getActualTypeArguments ( ) [0] ; } return Object.class ; }
public static Type[] getMapKeyAndValueTypes ( Type context , Class < ? > contextRawType ) { if ( context == Properties.class ) { return new Type[] { String.class , String.class } ; } Type mapType = getSupertype ( context , contextRawType , Map.class ) ; if ( mapType instanceof ParameterizedType ) { ParameterizedType mapParameterizedType = ( ParameterizedType ) mapType ; return mapParameterizedType.getActualTypeArguments ( ) ; } return new Type[] { Object.class , Object.class } ; }
public static Type resolve ( Type context , Class < ? > contextRawType , Type toResolve ) { return resolve ( context , contextRawType , toResolve , new HashSet < TypeVariable > ( ) ) ; }
static Type resolveTypeVariable ( Type context , Class < ? > contextRawType , TypeVariable < ? > unknown ) { Class < ? > declaredByRaw = declaringClassOf ( unknown ) ; if ( declaredByRaw == null ) { return unknown ; } Type declaredBy = getGenericSupertype ( context , contextRawType , declaredByRaw ) ; if ( declaredBy instanceof ParameterizedType ) { int index = indexOf ( declaredByRaw.getTypeParameters ( ) , unknown ) ; return ( ( ParameterizedType ) declaredBy ) .getActualTypeArguments ( ) [index] ; } return unknown ; }
private static int indexOf ( Object[] array , Object toFind ) { for ( int i = 0 , length = array.length ; i < length ; i++ ) { if ( toFind.equals ( array[i] ) ) { return i ; } } throw new NoSuchElementException ( ) ; }
private static Class < ? > declaringClassOf ( TypeVariable < ? > typeVariable ) { GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration ( ) ; return genericDeclaration instanceof Class ? ( Class < ? > ) genericDeclaration : null ; }
static void checkNotPrimitive ( Type type ) { checkArgument ( ! ( type instanceof Class < ? > ) || ! ( ( Class < ? > ) type ) .isPrimitive ( ) ) ; }
public Type[] getActualTypeArguments ( ) { return typeArguments.clone ( ) ; }
public Type getRawType ( ) { return rawType ; }
public Type getOwnerType ( ) { return ownerType ; }
public Type getGenericComponentType ( ) { return componentType ; }
public Type[] getUpperBounds ( ) { return new Type[] { upperBound } ; }
public Type[] getLowerBounds ( ) { return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY ; }
public void write ( JsonWriter out , Object array ) throws IOException { if ( array == null ) { out.nullValue ( ) ; return ; } out.beginArray ( ) ; for ( int i = 0 , length = Array.getLength ( array ) ; i < length ; i++ ) { E value = ( E ) Array.get ( array , i ) ; componentTypeAdapter.write ( out , value ) ; } out.endArray ( ) ; }
public void write ( JsonWriter out , Collection < E > collection ) throws IOException { if ( collection == null ) { out.nullValue ( ) ; return ; } out.beginArray ( ) ; for ( E element : collection ) { elementTypeAdapter.write ( out , element ) ; } out.endArray ( ) ; }
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { return typeToken.getRawType ( ) == Date.class ? ( TypeAdapter < T > ) new DateTypeAdapter ( ) : null ; }
public synchronized void write ( JsonWriter out , Date value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; return ; } String dateFormatAsString = dateFormats.get ( 0 ) .format ( value ) ; out.value ( dateFormatAsString ) ; }
public int read ( char[] buffer , int offset , int count ) throws IOException { throw new AssertionError ( ) ; }
public void close ( ) throws IOException { throw new AssertionError ( ) ; }
public void beginArray ( ) throws IOException { expect ( JsonToken.BEGIN_ARRAY ) ; JsonArray array = ( JsonArray ) peekStack ( ) ; push ( array.iterator ( ) ) ; pathIndices[stackSize - 1] = 0 ; }
public void endArray ( ) throws IOException { expect ( JsonToken.END_ARRAY ) ; popStack ( ) ; popStack ( ) ; if ( stackSize > 0 ) { pathIndices[stackSize - 1]++ ; } }
public void beginObject ( ) throws IOException { expect ( JsonToken.BEGIN_OBJECT ) ; JsonObject object = ( JsonObject ) peekStack ( ) ; push ( object.entrySet ( ) .iterator ( ) ) ; }
public void endObject ( ) throws IOException { expect ( JsonToken.END_OBJECT ) ; popStack ( ) ; popStack ( ) ; if ( stackSize > 0 ) { pathIndices[stackSize - 1]++ ; } }
public boolean hasNext ( ) throws IOException { JsonToken token = peek ( ) ; return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY ; }
private Object peekStack ( ) { return stack[stackSize - 1] ; }
private Object popStack ( ) { Object result = stack[--stackSize] ; stack[stackSize] = null ; return result ; }
private void expect ( JsonToken expected ) throws IOException { if ( peek ( ) != expected ) { throw new IllegalStateException ( " Expected " + expected + " but was " + peek ( ) + locationString ( ) ) ; } }
public String nextName ( ) throws IOException { expect ( JsonToken.NAME ) ; Iterator < ? > i = ( Iterator < ? > ) peekStack ( ) ; Map.Entry < ? , ? > entry = ( Map.Entry < ? , ? > ) i.next ( ) ; String result = ( String ) entry.getKey ( ) ; pathNames[stackSize - 1] = result ; push ( entry.getValue ( ) ) ; return result ; }
public String nextString ( ) throws IOException { JsonToken token = peek ( ) ; if ( token != JsonToken.STRING && token != JsonToken.NUMBER ) { throw new IllegalStateException ( " Expected " + JsonToken.STRING + " but was " + token + locationString ( ) ) ; } String result = ( ( JsonPrimitive ) popStack ( ) ) .getAsString ( ) ; if ( stackSize > 0 ) { pathIndices[stackSize - 1]++ ; } return result ; }
public boolean nextBoolean ( ) throws IOException { expect ( JsonToken.BOOLEAN ) ; boolean result = ( ( JsonPrimitive ) popStack ( ) ) .getAsBoolean ( ) ; if ( stackSize > 0 ) { pathIndices[stackSize - 1]++ ; } return result ; }
public void nextNull ( ) throws IOException { expect ( JsonToken.NULL ) ; popStack ( ) ; if ( stackSize > 0 ) { pathIndices[stackSize - 1]++ ; } }
public double nextDouble ( ) throws IOException { JsonToken token = peek ( ) ; if ( token != JsonToken.NUMBER && token != JsonToken.STRING ) { throw new IllegalStateException ( " Expected " + JsonToken.NUMBER + " but was " + token + locationString ( ) ) ; } double result = ( ( JsonPrimitive ) peekStack ( ) ) .getAsDouble ( ) ; if ( !isLenient ( ) && ( Double.isNaN ( result ) || Double.isInfinite ( result ) ) ) { throw new NumberFormatException ( " JSON forbids NaN and infinities: " + result ) ; } popStack ( ) ; if ( stackSize > 0 ) { pathIndices[stackSize - 1]++ ; } return result ; }
public long nextLong ( ) throws IOException { JsonToken token = peek ( ) ; if ( token != JsonToken.NUMBER && token != JsonToken.STRING ) { throw new IllegalStateException ( " Expected " + JsonToken.NUMBER + " but was " + token + locationString ( ) ) ; } long result = ( ( JsonPrimitive ) peekStack ( ) ) .getAsLong ( ) ; popStack ( ) ; if ( stackSize > 0 ) { pathIndices[stackSize - 1]++ ; } return result ; }
public int nextInt ( ) throws IOException { JsonToken token = peek ( ) ; if ( token != JsonToken.NUMBER && token != JsonToken.STRING ) { throw new IllegalStateException ( " Expected " + JsonToken.NUMBER + " but was " + token + locationString ( ) ) ; } int result = ( ( JsonPrimitive ) peekStack ( ) ) .getAsInt ( ) ; popStack ( ) ; if ( stackSize > 0 ) { pathIndices[stackSize - 1]++ ; } return result ; }
public void close ( ) throws IOException { stack = new Object[] { SENTINEL_CLOSED } ; stackSize = 1 ; }
public void skipValue ( ) throws IOException { if ( peek ( ) == JsonToken.NAME ) { nextName ( ) ; pathNames[stackSize - 2] = " null " ; } else { popStack ( ) ; if ( stackSize > 0 ) { pathNames[stackSize - 1] = " null " ; } } if ( stackSize > 0 ) { pathIndices[stackSize - 1]++ ; } }
public void promoteNameToValue ( ) throws IOException { expect ( JsonToken.NAME ) ; Iterator < ? > i = ( Iterator < ? > ) peekStack ( ) ; Map.Entry < ? , ? > entry = ( Map.Entry < ? , ? > ) i.next ( ) ; push ( entry.getValue ( ) ) ; push ( new JsonPrimitive ( ( String ) entry.getKey ( ) ) ) ; }
private String locationString ( ) { return " at path " + getPath ( ) ; }
public void write ( char[] buffer , int offset , int counter ) { throw new AssertionError ( ) ; }
public void flush ( ) throws IOException { throw new AssertionError ( ) ; }
public JsonElement get ( ) { if ( !stack.isEmpty ( ) ) { throw new IllegalStateException ( " Expected one JSON element but was " + stack ) ; } return product ; }
private JsonElement peek ( ) { return stack.get ( stack.size ( ) - 1 ) ; }
public JsonWriter beginArray ( ) throws IOException { JsonArray array = new JsonArray ( ) ; put ( array ) ; stack.add ( array ) ; return this ; }
public JsonWriter endArray ( ) throws IOException { if ( stack.isEmpty ( ) || pendingName != null ) { throw new IllegalStateException ( ) ; } JsonElement element = peek ( ) ; if ( element instanceof JsonArray ) { stack.remove ( stack.size ( ) - 1 ) ; return this ; } throw new IllegalStateException ( ) ; }
public JsonWriter beginObject ( ) throws IOException { JsonObject object = new JsonObject ( ) ; put ( object ) ; stack.add ( object ) ; return this ; }
public JsonWriter endObject ( ) throws IOException { if ( stack.isEmpty ( ) || pendingName != null ) { throw new IllegalStateException ( ) ; } JsonElement element = peek ( ) ; if ( element instanceof JsonObject ) { stack.remove ( stack.size ( ) - 1 ) ; return this ; } throw new IllegalStateException ( ) ; }
public JsonWriter name ( String name ) throws IOException { if ( stack.isEmpty ( ) || pendingName != null ) { throw new IllegalStateException ( ) ; } JsonElement element = peek ( ) ; if ( element instanceof JsonObject ) { pendingName = name ; return this ; } throw new IllegalStateException ( ) ; }
public JsonWriter nullValue ( ) throws IOException { put ( JsonNull.INSTANCE ) ; return this ; }
public JsonWriter value ( boolean value ) throws IOException { put ( new JsonPrimitive ( value ) ) ; return this ; }
public JsonWriter value ( double value ) throws IOException { if ( !isLenient ( ) && ( Double.isNaN ( value ) || Double.isInfinite ( value ) ) ) { throw new IllegalArgumentException ( " JSON forbids NaN and infinities: " + value ) ; } put ( new JsonPrimitive ( value ) ) ; return this ; }
public JsonWriter value ( long value ) throws IOException { put ( new JsonPrimitive ( value ) ) ; return this ; }
public void close ( ) throws IOException { if ( !stack.isEmpty ( ) ) { throw new IOException ( " Incomplete document " ) ; } stack.add ( SENTINEL_CLOSED ) ; }
private TypeAdapter < ? > getKeyAdapter ( Gson context , Type keyType ) { return ( keyType == boolean.class || keyType == Boolean.class ) ? TypeAdapters.BOOLEAN_AS_STRING : context.getAdapter ( TypeToken.get ( keyType ) ) ; }
public void write ( JsonWriter out , Object value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; return ; } TypeAdapter < Object > typeAdapter = ( TypeAdapter < Object > ) gson.getAdapter ( value.getClass ( ) ) ; if ( typeAdapter instanceof ObjectTypeAdapter ) { out.beginObject ( ) ; out.endObject ( ) ; return ; } typeAdapter.write ( out , value ) ; }
public boolean excludeField ( Field f , boolean serialize ) { return excludeField ( f , serialize , excluder ) ; }
static boolean excludeField ( Field f , boolean serialize , Excluder excluder ) { return !excluder.excludeClass ( f.getType ( ) , serialize ) && !excluder.excludeField ( f , serialize ) ; }
void write ( JsonWriter writer , Object value ) throws IOException , IllegalAccessException { Object fieldValue = field.get ( value ) ; TypeAdapter t = jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper ( context , typeAdapter , fieldType.getType ( ) ) ; t.write ( writer , fieldValue ) ; }
void read ( JsonReader reader , Object value ) throws IOException , IllegalAccessException { Object fieldValue = typeAdapter.read ( reader ) ; if ( fieldValue != null || !isPrimitive ) { field.set ( value , fieldValue ) ; } }
public boolean writeField ( Object value ) throws IOException , IllegalAccessException { if ( !serialized ) return false ; Object fieldValue = field.get ( value ) ; return fieldValue != value ; }
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { return typeToken.getRawType ( ) == java.sql.Date.class ? ( TypeAdapter < T > ) new SqlDateTypeAdapter ( ) : null ; }
public synchronized void write ( JsonWriter out , java.sql.Date value ) throws IOException { out.value ( value == null ? null : format.format ( value ) ) ; }
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { return typeToken.getRawType ( ) == Time.class ? ( TypeAdapter < T > ) new TimeTypeAdapter ( ) : null ; }
public synchronized void write ( JsonWriter out , Time value ) throws IOException { out.value ( value == null ? null : format.format ( value ) ) ; }
public void write ( JsonWriter out , T value ) throws IOException { if ( serializer == null ) { delegate ( ) .write ( out , value ) ; return ; } if ( value == null ) { out.nullValue ( ) ; return ; } JsonElement tree = serializer.serialize ( value , typeToken.getType ( ) , context ) ; Streams.write ( tree , out ) ; }
private TypeAdapter < T > delegate ( ) { TypeAdapter < T > d = delegate ; return d != null ? d : ( delegate = gson.getDelegateAdapter ( skipPast , typeToken ) ) ; }
public static TypeAdapterFactory newFactoryWithMatchRawType ( TypeToken < ? > exactType , Object typeAdapter ) { boolean matchRawType = exactType.getType ( ) == exactType.getRawType ( ) ; return new SingleTypeFactory ( typeAdapter , exactType , matchRawType , null ) ; }
public static TypeAdapterFactory newTypeHierarchyFactory ( Class < ? > hierarchyType , Object typeAdapter ) { return new SingleTypeFactory ( typeAdapter , null , false , hierarchyType ) ; }
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > type ) { boolean matches = exactType != null ? exactType.equals ( type ) || matchRawType && exactType.getType ( ) == type.getRawType ( ) : hierarchyType.isAssignableFrom ( type.getRawType ( ) ) ; return matches ? new TreeTypeAdapter < T > ( ( JsonSerializer < T > ) serializer , ( JsonDeserializer < T > ) deserializer , gson , type , this ) : null ; }
public JsonElement serialize ( Object src ) { return gson.toJsonTree ( src ) ; }
public JsonElement serialize ( Object src , Type typeOfSrc ) { return gson.toJsonTree ( src , typeOfSrc ) ; }
public < R > R deserialize ( JsonElement json , Type typeOfT ) throws JsonParseException { return ( R ) gson.fromJson ( json , typeOfT ) ; }
public T read ( JsonReader in ) throws IOException { return delegate.read ( in ) ; }
private Type getRuntimeTypeIfMoreSpecific ( Type type , Object value ) { if ( value != null && ( type == Object.class || type instanceof TypeVariable < ? > || type instanceof Class < ? > ) ) { type = value.getClass ( ) ; } return type ; }
public void write ( JsonWriter out , BitSet src ) throws IOException { out.beginArray ( ) ; for ( int i = 0 , length = src.length ( ) ; i < length ; i++ ) { int value = ( src.get ( i ) ) ? 1 : 0 ; out.value ( value ) ; } out.endArray ( ) ; }
public void write ( JsonWriter out , Boolean value ) throws IOException { out.value ( value ) ; }
public void write ( JsonWriter out , Boolean value ) throws IOException { out.value ( value == null ? " null " : value.toString ( ) ) ; }
public void write ( JsonWriter out , Number value ) throws IOException { out.value ( value ) ; }
public AtomicInteger read ( JsonReader in ) throws IOException { try { return new AtomicInteger ( in.nextInt ( ) ) ; } catch ( NumberFormatException e ) { throw new JsonSyntaxException ( e ) ; } }
public void write ( JsonWriter out , AtomicInteger value ) throws IOException { out.value ( value.get ( ) ) ; }
public AtomicBoolean read ( JsonReader in ) throws IOException { return new AtomicBoolean ( in.nextBoolean ( ) ) ; }
public void write ( JsonWriter out , AtomicBoolean value ) throws IOException { out.value ( value.get ( ) ) ; }
public void write ( JsonWriter out , AtomicIntegerArray value ) throws IOException { out.beginArray ( ) ; for ( int i = 0 , length = value.length ( ) ; i < length ; i++ ) { out.value ( value.get ( i ) ) ; } out.endArray ( ) ; }
public void write ( JsonWriter out , Character value ) throws IOException { out.value ( value == null ? null : String.valueOf ( value ) ) ; }
public void write ( JsonWriter out , String value ) throws IOException { out.value ( value ) ; }
public void write ( JsonWriter out , BigDecimal value ) throws IOException { out.value ( value ) ; }
public void write ( JsonWriter out , BigInteger value ) throws IOException { out.value ( value ) ; }
public void write ( JsonWriter out , StringBuilder value ) throws IOException { out.value ( value == null ? null : value.toString ( ) ) ; }
public void write ( JsonWriter out , StringBuffer value ) throws IOException { out.value ( value == null ? null : value.toString ( ) ) ; }
public void write ( JsonWriter out , URL value ) throws IOException { out.value ( value == null ? null : value.toExternalForm ( ) ) ; }
public void write ( JsonWriter out , URI value ) throws IOException { out.value ( value == null ? null : value.toASCIIString ( ) ) ; }
public void write ( JsonWriter out , InetAddress value ) throws IOException { out.value ( value == null ? null : value.getHostAddress ( ) ) ; }
public void write ( JsonWriter out , UUID value ) throws IOException { out.value ( value == null ? null : value.toString ( ) ) ; }
public Currency read ( JsonReader in ) throws IOException { return Currency.getInstance ( in.nextString ( ) ) ; }
public void write ( JsonWriter out , Currency value ) throws IOException { out.value ( value.getCurrencyCode ( ) ) ; }
public Timestamp read ( JsonReader in ) throws IOException { Date date = dateTypeAdapter.read ( in ) ; return date != null ? new Timestamp ( date.getTime ( ) ) : null ; }
public void write ( JsonWriter out , Timestamp value ) throws IOException { dateTypeAdapter.write ( out , value ) ; }
public void write ( JsonWriter out , Locale value ) throws IOException { out.value ( value == null ? null : value.toString ( ) ) ; }
public void write ( JsonWriter out , T value ) throws IOException { out.value ( value == null ? null : constantToName.get ( value ) ) ; }
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { return typeToken.equals ( type ) ? ( TypeAdapter < T > ) typeAdapter : null ; }
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { return typeToken.getRawType ( ) == type ? ( TypeAdapter < T > ) typeAdapter : null ; }
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { Class < ? super T > rawType = typeToken.getRawType ( ) ; return ( rawType == unboxed || rawType == boxed ) ? ( TypeAdapter < T > ) typeAdapter : null ; }
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { Class < ? super T > rawType = typeToken.getRawType ( ) ; return ( rawType == base || rawType == sub ) ? ( TypeAdapter < T > ) typeAdapter : null ; }
public void write ( JsonWriter out , T1 value ) throws IOException { typeAdapter.write ( out , value ) ; }
public T1 read ( JsonReader in ) throws IOException { T1 result = typeAdapter.read ( in ) ; if ( result != null && !requestedType.isInstance ( result ) ) { throw new JsonSyntaxException ( " Expected a " + requestedType.getName ( ) + " but was " + result.getClass ( ) .getName ( ) ) ; } return result ; }
public static String format ( Date date ) { return format ( date , false , TIMEZONE_UTC ) ; }
public static String format ( Date date , boolean millis ) { return format ( date , millis , TIMEZONE_UTC ) ; }
private static boolean checkOffset ( String value , int offset , char expected ) { return ( offset < value.length ( ) ) && ( value.charAt ( offset ) == expected ) ; }
private static void padInt ( StringBuilder buffer , int value , int length ) { String strValue = Integer.toString ( value ) ; for ( int i = length - strValue.length ( ) ; i > 0 ; i-- ) { buffer.append ( '0' ) ; } buffer.append ( strValue ) ; }
private static int indexOfNonDigit ( String string , int offset ) { for ( int i = offset ; i < string.length ( ) ; i++ ) { char c = string.charAt ( i ) ; if ( c < '0' || c > '9' ) return i ; } return string.length ( ) ; }
public T construct ( ) { return typeCreator.createInstance ( type ) ; }
public T construct ( ) { return rawTypeCreator.createInstance ( type ) ; }
public T construct ( ) { try { Object[] args = null ; return ( T ) constructor.newInstance ( args ) ; } catch ( InstantiationException e ) { throw new RuntimeException ( " Failed to invoke " + constructor + " with no args " , e ) ; } catch ( InvocationTargetException e ) { throw new RuntimeException ( " Failed to invoke " + constructor + " with no args " , e.getTargetException ( ) ) ; } catch ( IllegalAccessException e ) { throw new AssertionError ( e ) ; } }
public T construct ( ) { return ( T ) new TreeSet < Object > ( ) ; }
public T construct ( ) { if ( type instanceof ParameterizedType ) { Type elementType = ( ( ParameterizedType ) type ) .getActualTypeArguments ( ) [0] ; if ( elementType instanceof Class ) { return ( T ) EnumSet.noneOf ( ( Class ) elementType ) ; } else { throw new JsonIOException ( " Invalid EnumSet type: " + type.toString ( ) ) ; } } else { throw new JsonIOException ( " Invalid EnumSet type: " + type.toString ( ) ) ; } }
public T construct ( ) { return ( T ) new LinkedHashSet < Object > ( ) ; }
public T construct ( ) { return ( T ) new ArrayDeque < Object > ( ) ; }
public T construct ( ) { return ( T ) new ArrayList < Object > ( ) ; }
public T construct ( ) { return ( T ) new ConcurrentSkipListMap < Object , Object > ( ) ; }
public T construct ( ) { return ( T ) new ConcurrentHashMap < Object , Object > ( ) ; }
public T construct ( ) { return ( T ) new TreeMap < Object , Object > ( ) ; }
public T construct ( ) { return ( T ) new LinkedHashMap < Object , Object > ( ) ; }
public T construct ( ) { return ( T ) new LinkedTreeMap < String , Object > ( ) ; }
public T construct ( ) { try { Object newInstance = unsafeAllocator.newInstance ( rawType ) ; return ( T ) newInstance ; } catch ( Exception e ) { throw new RuntimeException ( ( " Unable to invoke no-args constructor for " + type + " . " + " Registering an InstanceCreator with Gson for this type may fix this problem. " ) , e ) ; } }
protected Excluder clone ( ) { try { return ( Excluder ) super.clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new AssertionError ( e ) ; } }
public Excluder withVersion ( double ignoreVersionsAfter ) { Excluder result = clone ( ) ; result.version = ignoreVersionsAfter ; return result ; }
public Excluder withModifiers ( int... modifiers ) { Excluder result = clone ( ) ; result.modifiers = 0 ; for ( int modifier : modifiers ) { result.modifiers |= modifier ; } return result ; }
public Excluder disableInnerClassSerialization ( ) { Excluder result = clone ( ) ; result.serializeInnerClasses = false ; return result ; }
public Excluder excludeFieldsWithoutExposeAnnotation ( ) { Excluder result = clone ( ) ; result.requireExpose = true ; return result ; }
public Excluder withExclusionStrategy ( ExclusionStrategy exclusionStrategy , boolean serialization , boolean deserialization ) { Excluder result = clone ( ) ; if ( serialization ) { result.serializationStrategies = new ArrayList < ExclusionStrategy > ( serializationStrategies ) ; result.serializationStrategies.add ( exclusionStrategy ) ; } if ( deserialization ) { result.deserializationStrategies = new ArrayList < ExclusionStrategy > ( deserializationStrategies ) ; result.deserializationStrategies.add ( exclusionStrategy ) ; } return result ; }
public void write ( JsonWriter out , T value ) throws IOException { if ( skipSerialize ) { out.nullValue ( ) ; return ; } delegate ( ) .write ( out , value ) ; }
private TypeAdapter < T > delegate ( ) { TypeAdapter < T > d = delegate ; return d != null ? d : ( delegate = gson.getDelegateAdapter ( Excluder.this , type ) ) ; }
private boolean excludeClassChecks ( Class < ? > clazz ) { if ( version != Excluder.IGNORE_VERSIONS && !isValidVersion ( clazz.getAnnotation ( Since.class ) , clazz.getAnnotation ( Until.class ) ) ) { return true ; } if ( !serializeInnerClasses && isInnerClass ( clazz ) ) { return true ; } if ( isAnonymousOrLocal ( clazz ) ) { return true ; } return false ; }
private boolean isAnonymousOrLocal ( Class < ? > clazz ) { return !Enum.class.isAssignableFrom ( clazz ) && ( clazz.isAnonymousClass ( ) || clazz.isLocalClass ( ) ) ; }
private boolean isInnerClass ( Class < ? > clazz ) { return clazz.isMemberClass ( ) && !isStatic ( clazz ) ; }
private boolean isStatic ( Class < ? > clazz ) { return ( clazz.getModifiers ( ) & Modifier.STATIC ) != 0 ; }
private boolean isValidVersion ( Since since , Until until ) { return isValidSince ( since ) && isValidUntil ( until ) ; }
private boolean isValidSince ( Since annotation ) { if ( annotation != null ) { double annotationVersion = annotation.value ( ) ; if ( annotationVersion > version ) { return false ; } } return true ; }
private boolean isValidUntil ( Until annotation ) { if ( annotation != null ) { double annotationVersion = annotation.value ( ) ; if ( annotationVersion < = version ) { return false ; } } return true ; }
private static int determineMajorJavaVersion ( ) { String javaVersion = System.getProperty ( " java.version " ) ; return getMajorJavaVersion ( javaVersion ) ; }
static int getMajorJavaVersion ( String javaVersion ) { int version = parseDotted ( javaVersion ) ; if ( version == -1 ) { version = extractBeginningInt ( javaVersion ) ; } if ( version == -1 ) { return 6 ; } return version ; }
private static int parseDotted ( String javaVersion ) { try { String[] parts = javaVersion.split ( " [._] " ) ; int firstVer = Integer.parseInt ( parts[0] ) ; if ( firstVer == 1 && parts.length > 1 ) { return Integer.parseInt ( parts[1] ) ; } else { return firstVer ; } } catch ( NumberFormatException e ) { return -1 ; } }
public static int getMajorJavaVersion ( ) { return majorJavaVersion ; }
public static boolean isJava9OrLater ( ) { return majorJavaVersion > = 9 ; }
public int intValue ( ) { try { return Integer.parseInt ( value ) ; } catch ( NumberFormatException e ) { try { return ( int ) Long.parseLong ( value ) ; } catch ( NumberFormatException nfe ) { return new BigDecimal ( value ) .intValue ( ) ; } } }
public long longValue ( ) { try { return Long.parseLong ( value ) ; } catch ( NumberFormatException e ) { return new BigDecimal ( value ) .longValue ( ) ; } }
public float floatValue ( ) { return Float.parseFloat ( value ) ; }
public double doubleValue ( ) { return Double.parseDouble ( value ) ; }
private Object writeReplace ( ) throws ObjectStreamException { return new BigDecimal ( value ) ; }
public int compare ( Comparable a , Comparable b ) { return a.compareTo ( b ) ; }
public int size ( ) { return size ; }
public V get ( Object key ) { Node < K , V > node = findByObject ( key ) ; return node != null ? node.value : null ; }
public boolean containsKey ( Object key ) { return findByObject ( key ) != null ; }
public V put ( K key , V value ) { if ( key == null ) { throw new NullPointerException ( " key == null " ) ; } Node < K , V > created = find ( key , true ) ; V result = created.value ; created.value = value ; return result ; }
public void clear ( ) { Arrays.fill ( table , null ) ; size = 0 ; modCount++ ; Node < K , V > header = this.header ; for ( Node < K , V > e = header.next ; e != header ; ) { Node < K , V > next = e.next ; e.next = e.prev = null ; e = next ; } header.next = header.prev = header ; }
public V remove ( Object key ) { Node < K , V > node = removeInternalByKey ( key ) ; return node != null ? node.value : null ; }
Node < K , V > findByEntry ( Entry < ? , ? > entry ) { Node < K , V > mine = findByObject ( entry.getKey ( ) ) ; boolean valuesEqual = mine != null && equal ( mine.value , entry.getValue ( ) ) ; return valuesEqual ? mine : null ; }
private boolean equal ( Object a , Object b ) { return a == b || ( a != null && a.equals ( b ) ) ; }
private static int secondaryHash ( int h ) { h ^= ( h > > > 20 ) ^ ( h > > > 12 ) ; return h ^ ( h > > > 7 ) ^ ( h > > > 4 ) ; }
Node < K , V > removeInternalByKey ( Object key ) { Node < K , V > node = findByObject ( key ) ; if ( node != null ) { removeInternal ( node , true ) ; } return node ; }
public Set < Entry < K , V > > entrySet ( ) { EntrySet result = entrySet ; return result != null ? result : ( entrySet = new EntrySet ( ) ) ; }
public Set < K > keySet ( ) { KeySet result = keySet ; return result != null ? result : ( keySet = new KeySet ( ) ) ; }
public K getKey ( ) { return key ; }
public V getValue ( ) { return value ; }
public V setValue ( V value ) { V oldValue = this.value ; this.value = value ; return oldValue ; }
public Node < K , V > first ( ) { Node < K , V > node = this ; Node < K , V > child = node.left ; while ( child != null ) { node = child ; child = node.left ; } return node ; }
public Node < K , V > last ( ) { Node < K , V > node = this ; Node < K , V > child = node.right ; while ( child != null ) { node = child ; child = node.right ; } return node ; }
private void doubleCapacity ( ) { table = doubleCapacity ( table ) ; threshold = ( table.length / 2 ) + ( table.length / 4 ) ; }
void reset ( Node < K , V > root ) { Node < K , V > stackTop = null ; for ( Node < K , V > n = root ; n != null ; n = n.left ) { n.parent = stackTop ; stackTop = n ; } this.stackTop = stackTop ; }
void reset ( int targetSize ) { int treeCapacity = Integer.highestOneBit ( targetSize ) * 2 - 1 ; leavesToSkip = treeCapacity - targetSize ; size = 0 ; leavesSkipped = 0 ; stack = null ; }
Node < K , V > root ( ) { Node < K , V > stackTop = this.stack ; if ( stackTop.parent != null ) { throw new IllegalStateException ( ) ; } return stackTop ; }
public final boolean hasNext ( ) { return next != header ; }
final Node < K , V > nextNode ( ) { Node < K , V > e = next ; if ( e == header ) { throw new NoSuchElementException ( ) ; } if ( modCount != expectedModCount ) { throw new ConcurrentModificationException ( ) ; } next = e.next ; return lastReturned = e ; }
public final void remove ( ) { if ( lastReturned == null ) { throw new IllegalStateException ( ) ; } removeInternal ( lastReturned , true ) ; lastReturned = null ; expectedModCount = modCount ; }
public Entry < K , V > next ( ) { return nextNode ( ) ; }
public boolean contains ( Object o ) { return o instanceof Entry && findByEntry ( ( Entry < ? , ? > ) o ) != null ; }
public boolean remove ( Object o ) { if ( ! ( o instanceof Entry ) ) { return false ; } Node < K , V > node = findByEntry ( ( Entry < ? , ? > ) o ) ; if ( node == null ) { return false ; } removeInternal ( node , true ) ; return true ; }
public void clear ( ) { LinkedHashTreeMap.this.clear ( ) ; }
public K next ( ) { return nextNode ( ) .key ; }
public boolean contains ( Object o ) { return containsKey ( o ) ; }
public boolean remove ( Object key ) { return removeInternalByKey ( key ) != null ; }
private Object writeReplace ( ) throws ObjectStreamException { return new LinkedHashMap < K , V > ( this ) ; }
public void clear ( ) { root = null ; size = 0 ; modCount++ ; Node < K , V > header = this.header ; header.next = header.prev = header ; }
public void clear ( ) { LinkedTreeMap.this.clear ( ) ; }
public static DateFormat getUSDateFormat ( int style ) { return new SimpleDateFormat ( getDateFormatPattern ( style ) , Locale.US ) ; }
public static DateFormat getUSDateTimeFormat ( int dateStyle , int timeStyle ) { String pattern = getDatePartOfDateTimePattern ( dateStyle ) + " " + getTimePartOfDateTimePattern ( timeStyle ) ; return new SimpleDateFormat ( pattern , Locale.US ) ; }
private static void add ( Map < Class < ? > , Class < ? > > forward , Map < Class < ? > , Class < ? > > backward , Class < ? > key , Class < ? > value ) { forward.put ( key , value ) ; backward.put ( value , key ) ; }
public static boolean isPrimitive ( Type type ) { return PRIMITIVE_TO_WRAPPER_TYPE.containsKey ( type ) ; }
public static boolean isWrapperType ( Type type ) { return WRAPPER_TO_PRIMITIVE_TYPE.containsKey ( $Gson$Preconditions.checkNotNull ( type ) ) ; }
public static < T > Class < T > wrap ( Class < T > type ) { @SuppressWarnings ( " unchecked " ) Class < T > wrapped = ( Class < T > ) PRIMITIVE_TO_WRAPPER_TYPE.get ( $Gson$Preconditions.checkNotNull ( type ) ) ; return ( wrapped == null ) ? type : wrapped ; }
public static < T > Class < T > unwrap ( Class < T > type ) { @SuppressWarnings ( " unchecked " ) Class < T > unwrapped = ( Class < T > ) WRAPPER_TO_PRIMITIVE_TYPE.get ( $Gson$Preconditions.checkNotNull ( type ) ) ; return ( unwrapped == null ) ? type : unwrapped ; }
public void makeAccessible ( AccessibleObject ao ) { ao.setAccessible ( true ) ; }
public static ReflectionAccessor getInstance ( ) { return instance ; }
public void makeAccessible ( AccessibleObject ao ) { boolean success = makeAccessibleWithUnsafe ( ao ) ; if ( !success ) { try { ao.setAccessible ( true ) ; } catch ( SecurityException e ) { throw new JsonIOException ( " Gson couldn't modify fields for " + ao + " \nand sun.misc.Unsafe not found.\nEither write a custom type adapter , " + " or make fields accessible , or include sun.misc.Unsafe. " , e ) ; } } }
public static void write ( JsonElement element , JsonWriter writer ) throws IOException { TypeAdapters.JSON_ELEMENT.write ( writer , element ) ; }
public static Writer writerForAppendable ( Appendable appendable ) { return appendable instanceof Writer ? ( Writer ) appendable : new AppendableWriter ( appendable ) ; }
public void write ( char[] chars , int offset , int length ) throws IOException { currentWrite.chars = chars ; appendable.append ( currentWrite , offset , offset + length ) ; }
public void write ( int i ) throws IOException { appendable.append ( ( char ) i ) ; }
public int length ( ) { return chars.length ; }
public char charAt ( int i ) { return chars[i] ; }
public CharSequence subSequence ( int start , int end ) { return new String ( chars , start , end - start ) ; }
public < T > T newInstance ( Class < T > c ) throws Exception { assertInstantiable ( c ) ; return ( T ) allocateInstance.invoke ( unsafe , c ) ; }
public < T > T newInstance ( Class < T > c ) throws Exception { assertInstantiable ( c ) ; return ( T ) newInstance.invoke ( null , c , constructorId ) ; }
public < T > T newInstance ( Class < T > c ) throws Exception { assertInstantiable ( c ) ; return ( T ) newInstance.invoke ( null , c , Object.class ) ; }
public JsonArray deepCopy ( ) { if ( !elements.isEmpty ( ) ) { JsonArray result = new JsonArray ( elements.size ( ) ) ; for ( JsonElement element : elements ) { result.add ( element.deepCopy ( ) ) ; } return result ; } return new JsonArray ( ) ; }
public void add ( Character character ) { elements.add ( character == null ? JsonNull.INSTANCE : new JsonPrimitive ( character ) ) ; }
public void add ( Number number ) { elements.add ( number == null ? JsonNull.INSTANCE : new JsonPrimitive ( number ) ) ; }
public void add ( String string ) { elements.add ( string == null ? JsonNull.INSTANCE : new JsonPrimitive ( string ) ) ; }
public void add ( JsonElement element ) { if ( element == null ) { element = JsonNull.INSTANCE ; } elements.add ( element ) ; }
public void addAll ( JsonArray array ) { elements.addAll ( array.elements ) ; }
public JsonElement set ( int index , JsonElement element ) { return elements.set ( index , element ) ; }
public boolean remove ( JsonElement element ) { return elements.remove ( element ) ; }
public JsonElement remove ( int index ) { return elements.remove ( index ) ; }
public boolean contains ( JsonElement element ) { return elements.contains ( element ) ; }
public int size ( ) { return elements.size ( ) ; }
public Iterator < JsonElement > iterator ( ) { return elements.iterator ( ) ; }
public JsonElement get ( int i ) { return elements.get ( i ) ; }
public Number getAsNumber ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsNumber ( ) ; } throw new IllegalStateException ( ) ; }
public String getAsString ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsString ( ) ; } throw new IllegalStateException ( ) ; }
public double getAsDouble ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsDouble ( ) ; } throw new IllegalStateException ( ) ; }
public BigDecimal getAsBigDecimal ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsBigDecimal ( ) ; } throw new IllegalStateException ( ) ; }
public BigInteger getAsBigInteger ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsBigInteger ( ) ; } throw new IllegalStateException ( ) ; }
public float getAsFloat ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsFloat ( ) ; } throw new IllegalStateException ( ) ; }
public long getAsLong ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsLong ( ) ; } throw new IllegalStateException ( ) ; }
public int getAsInt ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsInt ( ) ; } throw new IllegalStateException ( ) ; }
public byte getAsByte ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsByte ( ) ; } throw new IllegalStateException ( ) ; }
public char getAsCharacter ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsCharacter ( ) ; } throw new IllegalStateException ( ) ; }
public short getAsShort ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsShort ( ) ; } throw new IllegalStateException ( ) ; }
public boolean getAsBoolean ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsBoolean ( ) ; } throw new IllegalStateException ( ) ; }
public boolean isJsonArray ( ) { return this instanceof JsonArray ; }
public boolean isJsonObject ( ) { return this instanceof JsonObject ; }
public boolean isJsonPrimitive ( ) { return this instanceof JsonPrimitive ; }
public boolean isJsonNull ( ) { return this instanceof JsonNull ; }
public JsonObject getAsJsonObject ( ) { if ( isJsonObject ( ) ) { return ( JsonObject ) this ; } throw new IllegalStateException ( " Not a JSON Object: " + this ) ; }
public JsonArray getAsJsonArray ( ) { if ( isJsonArray ( ) ) { return ( JsonArray ) this ; } throw new IllegalStateException ( " Not a JSON Array: " + this ) ; }
public JsonPrimitive getAsJsonPrimitive ( ) { if ( isJsonPrimitive ( ) ) { return ( JsonPrimitive ) this ; } throw new IllegalStateException ( " Not a JSON Primitive: " + this ) ; }
public JsonNull getAsJsonNull ( ) { if ( isJsonNull ( ) ) { return ( JsonNull ) this ; } throw new IllegalStateException ( " Not a JSON Null: " + this ) ; }
public JsonNull deepCopy ( ) { return INSTANCE ; }
public JsonObject deepCopy ( ) { JsonObject result = new JsonObject ( ) ; for ( Map.Entry < String , JsonElement > entry : members.entrySet ( ) ) { result.add ( entry.getKey ( ) , entry.getValue ( ) .deepCopy ( ) ) ; } return result ; }
public void add ( String property , JsonElement value ) { if ( value == null ) { value = JsonNull.INSTANCE ; } members.put ( property , value ) ; }
public JsonElement remove ( String property ) { return members.remove ( property ) ; }
public void addProperty ( String property , String value ) { add ( property , createJsonElement ( value ) ) ; }
public void addProperty ( String property , Number value ) { add ( property , createJsonElement ( value ) ) ; }
public void addProperty ( String property , Boolean value ) { add ( property , createJsonElement ( value ) ) ; }
public void addProperty ( String property , Character value ) { add ( property , createJsonElement ( value ) ) ; }
private JsonElement createJsonElement ( Object value ) { return value == null ? JsonNull.INSTANCE : new JsonPrimitive ( value ) ; }
public Set < Map.Entry < String , JsonElement > > entrySet ( ) { return members.entrySet ( ) ; }
public Set < String > keySet ( ) { return members.keySet ( ) ; }
public int size ( ) { return members.size ( ) ; }
public boolean has ( String memberName ) { return members.containsKey ( memberName ) ; }
public JsonElement get ( String memberName ) { return members.get ( memberName ) ; }
public JsonPrimitive getAsJsonPrimitive ( String memberName ) { return ( JsonPrimitive ) members.get ( memberName ) ; }
public JsonArray getAsJsonArray ( String memberName ) { return ( JsonArray ) members.get ( memberName ) ; }
public JsonObject getAsJsonObject ( String memberName ) { return ( JsonObject ) members.get ( memberName ) ; }
public JsonElement parse ( String json ) throws JsonSyntaxException { return parse ( new StringReader ( json ) ) ; }
public JsonElement parse ( JsonReader json ) throws JsonIOException , JsonSyntaxException { boolean lenient = json.isLenient ( ) ; json.setLenient ( true ) ; try { return Streams.parse ( json ) ; } catch ( StackOverflowError e ) { throw new JsonParseException ( " Failed parsing JSON source: " + json + " to Json " , e ) ; } catch ( OutOfMemoryError e ) { throw new JsonParseException ( " Failed parsing JSON source: " + json + " to Json " , e ) ; } finally { json.setLenient ( lenient ) ; } }
public JsonPrimitive deepCopy ( ) { return this ; }
void setValue ( Object primitive ) { if ( primitive instanceof Character ) { char c = ( ( Character ) primitive ) .charValue ( ) ; this.value = String.valueOf ( c ) ; } else { $Gson$Preconditions.checkArgument ( primitive instanceof Number || isPrimitiveOrString ( primitive ) ) ; this.value = primitive ; } }
public boolean isBoolean ( ) { return value instanceof Boolean ; }
Boolean getAsBooleanWrapper ( ) { return ( Boolean ) value ; }
public boolean getAsBoolean ( ) { if ( isBoolean ( ) ) { return getAsBooleanWrapper ( ) .booleanValue ( ) ; } else { return Boolean.parseBoolean ( getAsString ( ) ) ; } }
public boolean isNumber ( ) { return value instanceof Number ; }
public Number getAsNumber ( ) { return value instanceof String ? new LazilyParsedNumber ( ( String ) value ) : ( Number ) value ; }
public boolean isString ( ) { return value instanceof String ; }
public String getAsString ( ) { if ( isNumber ( ) ) { return getAsNumber ( ) .toString ( ) ; } else if ( isBoolean ( ) ) { return getAsBooleanWrapper ( ) .toString ( ) ; } else { return ( String ) value ; } }
public double getAsDouble ( ) { return isNumber ( ) ? getAsNumber ( ) .doubleValue ( ) : Double.parseDouble ( getAsString ( ) ) ; }
public BigDecimal getAsBigDecimal ( ) { return value instanceof BigDecimal ? ( BigDecimal ) value : new BigDecimal ( value.toString ( ) ) ; }
public BigInteger getAsBigInteger ( ) { return value instanceof BigInteger ? ( BigInteger ) value : new BigInteger ( value.toString ( ) ) ; }
public float getAsFloat ( ) { return isNumber ( ) ? getAsNumber ( ) .floatValue ( ) : Float.parseFloat ( getAsString ( ) ) ; }
public long getAsLong ( ) { return isNumber ( ) ? getAsNumber ( ) .longValue ( ) : Long.parseLong ( getAsString ( ) ) ; }
public short getAsShort ( ) { return isNumber ( ) ? getAsNumber ( ) .shortValue ( ) : Short.parseShort ( getAsString ( ) ) ; }
public int getAsInt ( ) { return isNumber ( ) ? getAsNumber ( ) .intValue ( ) : Integer.parseInt ( getAsString ( ) ) ; }
public byte getAsByte ( ) { return isNumber ( ) ? getAsNumber ( ) .byteValue ( ) : Byte.parseByte ( getAsString ( ) ) ; }
public char getAsCharacter ( ) { return getAsString ( ) .charAt ( 0 ) ; }
private static boolean isPrimitiveOrString ( Object target ) { if ( target instanceof String ) { return true ; } Class < ? > classOfPrimitive = target.getClass ( ) ; for ( Class < ? > standardPrimitive : PRIMITIVE_TYPES ) { if ( standardPrimitive.isAssignableFrom ( classOfPrimitive ) ) { return true ; } } return false ; }
private static boolean isIntegral ( JsonPrimitive primitive ) { if ( primitive.value instanceof Number ) { Number number = ( Number ) primitive.value ; return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte ; } return false ; }
public JsonElement next ( ) throws JsonParseException { if ( !hasNext ( ) ) { throw new NoSuchElementException ( ) ; } try { return Streams.parse ( parser ) ; } catch ( StackOverflowError e ) { throw new JsonParseException ( " Failed parsing JSON source to Json " , e ) ; } catch ( OutOfMemoryError e ) { throw new JsonParseException ( " Failed parsing JSON source to Json " , e ) ; } catch ( JsonParseException e ) { throw e.getCause ( ) instanceof EOFException ? new NoSuchElementException ( ) : e ; } }
public boolean hasNext ( ) { synchronized ( lock ) { try { return parser.peek ( ) != JsonToken.END_DOCUMENT ; } catch ( MalformedJsonException e ) { throw new JsonSyntaxException ( e ) ; } catch ( IOException e ) { throw new JsonIOException ( e ) ; } } }
public JsonElement serialize ( Long value ) { return new JsonPrimitive ( value ) ; }
public JsonElement serialize ( Long value ) { return new JsonPrimitive ( String.valueOf ( value ) ) ; }
static Type getSuperclassTypeParameter ( Class < ? > subclass ) { Type superclass = subclass.getGenericSuperclass ( ) ; if ( superclass instanceof Class ) { throw new RuntimeException ( " Missing type parameter. " ) ; } ParameterizedType parameterized = ( ParameterizedType ) superclass ; return $Gson$Types.canonicalize ( parameterized.getActualTypeArguments ( ) [0] ) ; }
public final Class < ? super T > getRawType ( ) { return rawType ; }
public final Type getType ( ) { return type ; }
public boolean isAssignableFrom ( Class < ? > cls ) { return isAssignableFrom ( ( Type ) cls ) ; }
public boolean isAssignableFrom ( TypeToken < ? > token ) { return isAssignableFrom ( token.getType ( ) ) ; }
private static boolean typeEquals ( ParameterizedType from , ParameterizedType to , Map < String , Type > typeVarMap ) { if ( from.getRawType ( ) .equals ( to.getRawType ( ) ) ) { Type[] fromArgs = from.getActualTypeArguments ( ) ; Type[] toArgs = to.getActualTypeArguments ( ) ; for ( int i = 0 ; i < fromArgs.length ; i++ ) { if ( !matches ( fromArgs[i] , toArgs[i] , typeVarMap ) ) { return false ; } } return true ; } return false ; }
private static boolean matches ( Type from , Type to , Map < String , Type > typeMap ) { return to.equals ( from ) || ( from instanceof TypeVariable && to.equals ( typeMap.get ( ( ( TypeVariable < ? > ) from ) .getName ( ) ) ) ) ; }
public static TypeToken < ? > get ( Type type ) { return new TypeToken < Object > ( type ) ; }
public static < T > TypeToken < T > get ( Class < T > type ) { return new TypeToken < T > ( type ) ; }
public static TypeToken < ? > getParameterized ( Type rawType , Type... typeArguments ) { return new TypeToken < Object > ( $Gson$Types.newParameterizedTypeWithOwner ( null , rawType , typeArguments ) ) ; }
public static TypeToken < ? > getArray ( Type componentType ) { return new TypeToken < Object > ( $Gson$Types.arrayOf ( componentType ) ) ; }
public final void setLenient ( boolean lenient ) { this.lenient = lenient ; }
public final boolean isLenient ( ) { return lenient ; }
public void beginArray ( ) throws IOException { int p = peeked ; if ( p == PEEKED_NONE ) { p = doPeek ( ) ; } if ( p == PEEKED_BEGIN_ARRAY ) { push ( JsonScope.EMPTY_ARRAY ) ; pathIndices[stackSize - 1] = 0 ; peeked = PEEKED_NONE ; } else { throw new IllegalStateException ( " Expected BEGIN_ARRAY but was " + peek ( ) + locationString ( ) ) ; } }
public void endArray ( ) throws IOException { int p = peeked ; if ( p == PEEKED_NONE ) { p = doPeek ( ) ; } if ( p == PEEKED_END_ARRAY ) { stackSize-- ; pathIndices[stackSize - 1]++ ; peeked = PEEKED_NONE ; } else { throw new IllegalStateException ( " Expected END_ARRAY but was " + peek ( ) + locationString ( ) ) ; } }
public void beginObject ( ) throws IOException { int p = peeked ; if ( p == PEEKED_NONE ) { p = doPeek ( ) ; } if ( p == PEEKED_BEGIN_OBJECT ) { push ( JsonScope.EMPTY_OBJECT ) ; peeked = PEEKED_NONE ; } else { throw new IllegalStateException ( " Expected BEGIN_OBJECT but was " + peek ( ) + locationString ( ) ) ; } }
public void endObject ( ) throws IOException { int p = peeked ; if ( p == PEEKED_NONE ) { p = doPeek ( ) ; } if ( p == PEEKED_END_OBJECT ) { stackSize-- ; pathNames[stackSize] = null ; pathIndices[stackSize - 1]++ ; peeked = PEEKED_NONE ; } else { throw new IllegalStateException ( " Expected END_OBJECT but was " + peek ( ) + locationString ( ) ) ; } }
public boolean hasNext ( ) throws IOException { int p = peeked ; if ( p == PEEKED_NONE ) { p = doPeek ( ) ; } return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY ; }
public void close ( ) throws IOException { peeked = PEEKED_NONE ; stack[0] = JsonScope.CLOSED ; stackSize = 1 ; in.close ( ) ; }
private void push ( int newTop ) { if ( stackSize == stack.length ) { int[] newStack = new int[stackSize * 2] ; int[] newPathIndices = new int[stackSize * 2] ; String[] newPathNames = new String[stackSize * 2] ; System.arraycopy ( stack , 0 , newStack , 0 , stackSize ) ; System.arraycopy ( pathIndices , 0 , newPathIndices , 0 , stackSize ) ; System.arraycopy ( pathNames , 0 , newPathNames , 0 , stackSize ) ; stack = newStack ; pathIndices = newPathIndices ; pathNames = newPathNames ; } stack[stackSize++] = newTop ; }
private void checkLenient ( ) throws IOException { if ( !lenient ) { throw syntaxError ( " Use JsonReader.setLenient ( true ) to accept malformed JSON " ) ; } }
private void skipToEndOfLine ( ) throws IOException { while ( pos < limit || fillBuffer ( 1 ) ) { char c = buffer[pos++] ; if ( c == '\n' ) { lineNumber++ ; lineStart = pos ; break ; } else if ( c == '\r' ) { break ; } } }
String locationString ( ) { int line = lineNumber + 1 ; int column = pos - lineStart + 1 ; return " at line " + line + " column " + column + " path " + getPath ( ) ; }
private IOException syntaxError ( String message ) throws IOException { throw new MalformedJsonException ( message + locationString ( ) ) ; }
public final void setIndent ( String indent ) { if ( indent.length ( ) == 0 ) { this.indent = null ; this.separator = " : " ; } else { this.indent = indent ; this.separator = " : " ; } }
public boolean isLenient ( ) { return lenient ; }
public final void setHtmlSafe ( boolean htmlSafe ) { this.htmlSafe = htmlSafe ; }
public final boolean isHtmlSafe ( ) { return htmlSafe ; }
public final void setSerializeNulls ( boolean serializeNulls ) { this.serializeNulls = serializeNulls ; }
public final boolean getSerializeNulls ( ) { return serializeNulls ; }
public JsonWriter beginArray ( ) throws IOException { writeDeferredName ( ) ; return open ( EMPTY_ARRAY , " [ " ) ; }
public JsonWriter endArray ( ) throws IOException { return close ( EMPTY_ARRAY , NONEMPTY_ARRAY , " ] " ) ; }
public JsonWriter beginObject ( ) throws IOException { writeDeferredName ( ) ; return open ( EMPTY_OBJECT , " { " ) ; }
public JsonWriter endObject ( ) throws IOException { return close ( EMPTY_OBJECT , NONEMPTY_OBJECT , " } " ) ; }
private JsonWriter open ( int empty , String openBracket ) throws IOException { beforeValue ( ) ; push ( empty ) ; out.write ( openBracket ) ; return this ; }
private JsonWriter close ( int empty , int nonempty , String closeBracket ) throws IOException { int context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new IllegalStateException ( " Nesting problem. " ) ; } if ( deferredName != null ) { throw new IllegalStateException ( " Dangling name: " + deferredName ) ; } stackSize-- ; if ( context == nonempty ) { newline ( ) ; } out.write ( closeBracket ) ; return this ; }
private void push ( int newTop ) { if ( stackSize == stack.length ) { int[] newStack = new int[stackSize * 2] ; System.arraycopy ( stack , 0 , newStack , 0 , stackSize ) ; stack = newStack ; } stack[stackSize++] = newTop ; }
private int peek ( ) { if ( stackSize == 0 ) { throw new IllegalStateException ( " JsonWriter is closed. " ) ; } return stack[stackSize - 1] ; }
private void replaceTop ( int topOfStack ) { stack[stackSize - 1] = topOfStack ; }
public JsonWriter name ( String name ) throws IOException { if ( name == null ) { throw new NullPointerException ( " name == null " ) ; } if ( deferredName != null ) { throw new IllegalStateException ( ) ; } if ( stackSize == 0 ) { throw new IllegalStateException ( " JsonWriter is closed. " ) ; } deferredName = name ; return this ; }
private void writeDeferredName ( ) throws IOException { if ( deferredName != null ) { beforeName ( ) ; string ( deferredName ) ; deferredName = null ; } }
public JsonWriter nullValue ( ) throws IOException { if ( deferredName != null ) { if ( serializeNulls ) { writeDeferredName ( ) ; } else { deferredName = null ; return this ; } } beforeValue ( ) ; out.write ( " null " ) ; return this ; }
public JsonWriter value ( boolean value ) throws IOException { writeDeferredName ( ) ; beforeValue ( ) ; out.write ( value ? " true " : " false " ) ; return this ; }
public JsonWriter value ( double value ) throws IOException { writeDeferredName ( ) ; if ( !lenient && ( Double.isNaN ( value ) || Double.isInfinite ( value ) ) ) { throw new IllegalArgumentException ( " Numeric values must be finite , but was " + value ) ; } beforeValue ( ) ; out.append ( Double.toString ( value ) ) ; return this ; }
public JsonWriter value ( long value ) throws IOException { writeDeferredName ( ) ; beforeValue ( ) ; out.write ( Long.toString ( value ) ) ; return this ; }
public void flush ( ) throws IOException { if ( stackSize == 0 ) { throw new IllegalStateException ( " JsonWriter is closed. " ) ; } out.flush ( ) ; }
public void close ( ) throws IOException { out.close ( ) ; int size = stackSize ; if ( size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT ) { throw new IOException ( " Incomplete document " ) ; } stackSize = 0 ; }
private void newline ( ) throws IOException { if ( indent == null ) { return ; } out.write ( " \n " ) ; for ( int i = 1 , size = stackSize ; i < size ; i++ ) { out.write ( indent ) ; } }
private void beforeName ( ) throws IOException { int context = peek ( ) ; if ( context == NONEMPTY_OBJECT ) { out.write ( ' , ' ) ; } else if ( context != EMPTY_OBJECT ) { throw new IllegalStateException ( " Nesting problem. " ) ; } newline ( ) ; replaceTop ( DANGLING_NAME ) ; }
public final void toJson ( Writer out , T value ) throws IOException { JsonWriter writer = new JsonWriter ( out ) ; write ( writer , value ) ; }
public void write ( JsonWriter out , T value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; } else { TypeAdapter.this.write ( out , value ) ; } }
public final String toJson ( T value ) { StringWriter stringWriter = new StringWriter ( ) ; try { toJson ( stringWriter , value ) ; } catch ( IOException e ) { throw new AssertionError ( e ) ; } return stringWriter.toString ( ) ; }
public final JsonElement toJsonTree ( T value ) { try { JsonTreeWriter jsonWriter = new JsonTreeWriter ( ) ; write ( jsonWriter , value ) ; return jsonWriter.get ( ) ; } catch ( IOException e ) { throw new JsonIOException ( e ) ; } }
public final T fromJson ( Reader in ) throws IOException { JsonReader reader = new JsonReader ( in ) ; return read ( reader ) ; }
public final T fromJson ( String json ) throws IOException { return fromJson ( new StringReader ( json ) ) ; }
public final T fromJsonTree ( JsonElement jsonTree ) { try { JsonReader jsonReader = new JsonTreeReader ( jsonTree ) ; return read ( jsonReader ) ; } catch ( IOException e ) { throw new JsonIOException ( e ) ; } }
static < T > Optional < T > withType ( ) { return ( Optional < T > ) INSTANCE ; }
public boolean isPresent ( ) { return false ; }
public T or ( T defaultValue ) { return checkNotNull ( defaultValue , " use Optional.orNull ( ) instead of Optional.or ( null ) " ) ; }
public Optional < T > or ( Optional < ? extends T > secondChoice ) { return ( Optional < T > ) checkNotNull ( secondChoice ) ; }
public T or ( Supplier < ? extends T > supplier ) { return checkNotNull ( supplier.get ( ) , " use Optional.orNull ( ) instead of a Supplier that returns null " ) ; }
public Set < T > asSet ( ) { return Collections.emptySet ( ) ; }
public < V > Optional < V > transform ( Function < ? super T , V > function ) { checkNotNull ( function ) ; return Optional.absent ( ) ; }
private Object readResolve ( ) { return INSTANCE ; }
private boolean tryToComputeNext ( ) { state = State.FAILED ; next = computeNext ( ) ; if ( state != State.DONE ) { state = State.READY ; return true ; } return false ; }
public final T next ( ) { if ( !hasNext ( ) ) { throw new NoSuchElementException ( ) ; } state = State.NOT_READY ; T result = next ; next = null ; return result ; }
public static String toLowerCase ( CharSequence chars ) { if ( chars instanceof String ) { return toLowerCase ( ( String ) chars ) ; } char[] newChars = new char[chars.length ( ) ] ; for ( int i = 0 ; i < newChars.length ; i++ ) { newChars[i] = toLowerCase ( chars.charAt ( i ) ) ; } return String.valueOf ( newChars ) ; }
public static char toLowerCase ( char c ) { return isUpperCase ( c ) ? ( char ) ( c ^ CASE_MASK ) : c ; }
public static String toUpperCase ( CharSequence chars ) { if ( chars instanceof String ) { return toUpperCase ( ( String ) chars ) ; } char[] newChars = new char[chars.length ( ) ] ; for ( int i = 0 ; i < newChars.length ; i++ ) { newChars[i] = toUpperCase ( chars.charAt ( i ) ) ; } return String.valueOf ( newChars ) ; }
public static char toUpperCase ( char c ) { return isLowerCase ( c ) ? ( char ) ( c ^ CASE_MASK ) : c ; }
public static boolean isLowerCase ( char c ) { return ( c > = 'a' ) && ( c < = 'z' ) ; }
public static boolean isUpperCase ( char c ) { return ( c > = 'A' ) && ( c < = 'Z' ) ; }
public static String truncate ( CharSequence seq , int maxLength , String truncationIndicator ) { checkNotNull ( seq ) ; int truncationLength = maxLength - truncationIndicator.length ( ) ; checkArgument ( truncationLength > = 0 , " maxLength ( %s ) must be > = length of the truncation indicator ( %s ) " , maxLength , truncationIndicator.length ( ) ) ; if ( seq.length ( ) < = maxLength ) { String string = seq.toString ( ) ; if ( string.length ( ) < = maxLength ) { return string ; } seq = string ; } return new StringBuilder ( maxLength ) .append ( seq , 0 , truncationLength ) .append ( truncationIndicator ) .toString ( ) ; }
private static int getAlphaIndex ( char c ) { return ( char ) ( ( c | CASE_MASK ) - 'a' ) ; }
public final String to ( CaseFormat format , String str ) { checkNotNull ( format ) ; checkNotNull ( str ) ; return ( format == this ) ? str : convert ( format , str ) ; }
public Converter < String , String > converterTo ( CaseFormat targetFormat ) { return new StringConverter ( this , targetFormat ) ; }
protected String doForward ( String s ) { return sourceFormat.to ( targetFormat , s ) ; }
protected String doBackward ( String s ) { return targetFormat.to ( sourceFormat , s ) ; }
String normalizeFirstWord ( String word ) { return normalizeWord ( word ) ; }
private static String firstCharOnlyToUpper ( String word ) { return word.isEmpty ( ) ? word : Ascii.toUpperCase ( word.charAt ( 0 ) ) + Ascii.toLowerCase ( word.substring ( 1 ) ) ; }
String normalizeWord ( String word ) { return Ascii.toLowerCase ( word ) ; }
String convert ( CaseFormat format , String s ) { if ( format == LOWER_UNDERSCORE ) { return s.replace ( '-' , '_' ) ; } if ( format == UPPER_UNDERSCORE ) { return Ascii.toUpperCase ( s.replace ( '-' , '_' ) ) ; } return super.convert ( format , s ) ; }
String convert ( CaseFormat format , String s ) { if ( format == LOWER_HYPHEN ) { return s.replace ( '_' , '-' ) ; } if ( format == UPPER_UNDERSCORE ) { return Ascii.toUpperCase ( s ) ; } return super.convert ( format , s ) ; }
String normalizeWord ( String word ) { return firstCharOnlyToUpper ( word ) ; }
String normalizeFirstWord ( String word ) { return Ascii.toLowerCase ( word ) ; }
String normalizeWord ( String word ) { return Ascii.toUpperCase ( word ) ; }
String convert ( CaseFormat format , String s ) { if ( format == LOWER_HYPHEN ) { return Ascii.toLowerCase ( s.replace ( '_' , '-' ) ) ; } if ( format == LOWER_UNDERSCORE ) { return Ascii.toLowerCase ( s ) ; } return super.convert ( format , s ) ; }
public static CharMatcher any ( ) { return Any.INSTANCE ; }
public static CharMatcher none ( ) { return None.INSTANCE ; }
public static CharMatcher whitespace ( ) { return Whitespace.INSTANCE ; }
public static CharMatcher noneOf ( CharSequence sequence ) { return anyOf ( sequence ) .negate ( ) ; }
public static CharMatcher inRange ( final char startInclusive , final char endInclusive ) { return new InRange ( startInclusive , endInclusive ) ; }
public static CharMatcher forPredicate ( final Predicate < ? super Character > predicate ) { return predicate instanceof CharMatcher ? ( CharMatcher ) predicate : new ForPredicate ( predicate ) ; }
public CharMatcher negate ( ) { return new Negated ( this ) ; }
public CharMatcher and ( CharMatcher other ) { return new And ( this , other ) ; }
public CharMatcher or ( CharMatcher other ) { return new Or ( this , other ) ; }
public CharMatcher precomputed ( ) { return Platform.precomputeCharMatcher ( this ) ; }
private static boolean isSmall ( int totalCharacters , int tableLength ) { return totalCharacters < = SmallCharMatcher.MAX_SIZE && tableLength > ( totalCharacters * 4 * Character.SIZE ) ; }
void setBits ( BitSet table ) { for ( int c = Character.MAX_VALUE ; c > = Character.MIN_VALUE ; c-- ) { if ( matches ( ( char ) c ) ) { table.set ( c ) ; } } }
public boolean matchesAnyOf ( CharSequence sequence ) { return !matchesNoneOf ( sequence ) ; }
public boolean matchesAllOf ( CharSequence sequence ) { for ( int i = sequence.length ( ) - 1 ; i > = 0 ; i-- ) { if ( !matches ( sequence.charAt ( i ) ) ) { return false ; } } return true ; }
public boolean matchesNoneOf ( CharSequence sequence ) { return indexIn ( sequence ) == -1 ; }
public int indexIn ( CharSequence sequence ) { return indexIn ( sequence , 0 ) ; }
public int indexIn ( CharSequence sequence , int start ) { int length = sequence.length ( ) ; checkPositionIndex ( start , length ) ; for ( int i = start ; i < length ; i++ ) { if ( matches ( sequence.charAt ( i ) ) ) { return i ; } } return -1 ; }
public int lastIndexIn ( CharSequence sequence ) { for ( int i = sequence.length ( ) - 1 ; i > = 0 ; i-- ) { if ( matches ( sequence.charAt ( i ) ) ) { return i ; } } return -1 ; }
public int countIn ( CharSequence sequence ) { int count = 0 ; for ( int i = 0 ; i < sequence.length ( ) ; i++ ) { if ( matches ( sequence.charAt ( i ) ) ) { count++ ; } } return count ; }
public String retainFrom ( CharSequence sequence ) { return negate ( ) .removeFrom ( sequence ) ; }
public String replaceFrom ( CharSequence sequence , char replacement ) { String string = sequence.toString ( ) ; int pos = indexIn ( string ) ; if ( pos == -1 ) { return string ; } char[] chars = string.toCharArray ( ) ; chars[pos] = replacement ; for ( int i = pos + 1 ; i < chars.length ; i++ ) { if ( matches ( chars[i] ) ) { chars[i] = replacement ; } } return new String ( chars ) ; }
public String trimLeadingFrom ( CharSequence sequence ) { int len = sequence.length ( ) ; for ( int first = 0 ; first < len ; first++ ) { if ( !matches ( sequence.charAt ( first ) ) ) { return sequence.subSequence ( first , len ) .toString ( ) ; } } return " " ; }
public String trimTrailingFrom ( CharSequence sequence ) { int len = sequence.length ( ) ; for ( int last = len - 1 ; last > = 0 ; last-- ) { if ( !matches ( sequence.charAt ( last ) ) ) { return sequence.subSequence ( 0 , last + 1 ) .toString ( ) ; } } return " " ; }
public boolean apply ( Character character ) { return matches ( character ) ; }
private static String showCharacter ( char c ) { String hex = " 0123456789ABCDEF " ; char[] tmp = { '\\' , 'u' , '\0' , '\0' , '\0' , '\0' } ; for ( int i = 0 ; i < 4 ; i++ ) { tmp[5 - i] = hex.charAt ( c & 0xF ) ; c = ( char ) ( c > > 4 ) ; } return String.copyValueOf ( tmp ) ; }
public final CharMatcher precomputed ( ) { return this ; }
public CharMatcher negate ( ) { return new NegatedFastMatcher ( this ) ; }
public boolean matches ( char c ) { return table.get ( c ) ; }
void setBits ( BitSet bitSet ) { bitSet.or ( table ) ; }
public boolean matches ( char c ) { return true ; }
public int indexIn ( CharSequence sequence ) { return ( sequence.length ( ) == 0 ) ? -1 : 0 ; }
public int indexIn ( CharSequence sequence , int start ) { int length = sequence.length ( ) ; checkPositionIndex ( start , length ) ; return ( start == length ) ? -1 : start ; }
public int lastIndexIn ( CharSequence sequence ) { return sequence.length ( ) - 1 ; }
public boolean matchesAllOf ( CharSequence sequence ) { checkNotNull ( sequence ) ; return true ; }
public boolean matchesNoneOf ( CharSequence sequence ) { return sequence.length ( ) == 0 ; }
public String removeFrom ( CharSequence sequence ) { checkNotNull ( sequence ) ; return " " ; }
public String replaceFrom ( CharSequence sequence , char replacement ) { char[] array = new char[sequence.length ( ) ] ; Arrays.fill ( array , replacement ) ; return new String ( array ) ; }
public String replaceFrom ( CharSequence sequence , CharSequence replacement ) { StringBuilder result = new StringBuilder ( sequence.length ( ) * replacement.length ( ) ) ; for ( int i = 0 ; i < sequence.length ( ) ; i++ ) { result.append ( replacement ) ; } return result.toString ( ) ; }
public String collapseFrom ( CharSequence sequence , char replacement ) { return ( sequence.length ( ) == 0 ) ? " " : String.valueOf ( replacement ) ; }
public String trimFrom ( CharSequence sequence ) { checkNotNull ( sequence ) ; return " " ; }
public int countIn ( CharSequence sequence ) { return sequence.length ( ) ; }
public CharMatcher and ( CharMatcher other ) { return checkNotNull ( other ) ; }
public CharMatcher or ( CharMatcher other ) { checkNotNull ( other ) ; return this ; }
public CharMatcher negate ( ) { return none ( ) ; }
public boolean matches ( char c ) { return false ; }
public int indexIn ( CharSequence sequence ) { checkNotNull ( sequence ) ; return -1 ; }
public int indexIn ( CharSequence sequence , int start ) { int length = sequence.length ( ) ; checkPositionIndex ( start , length ) ; return -1 ; }
public int lastIndexIn ( CharSequence sequence ) { checkNotNull ( sequence ) ; return -1 ; }
public boolean matchesAllOf ( CharSequence sequence ) { return sequence.length ( ) == 0 ; }
public boolean matchesNoneOf ( CharSequence sequence ) { checkNotNull ( sequence ) ; return true ; }
public String removeFrom ( CharSequence sequence ) { return sequence.toString ( ) ; }
public String replaceFrom ( CharSequence sequence , char replacement ) { return sequence.toString ( ) ; }
public String replaceFrom ( CharSequence sequence , CharSequence replacement ) { checkNotNull ( replacement ) ; return sequence.toString ( ) ; }
public String collapseFrom ( CharSequence sequence , char replacement ) { return sequence.toString ( ) ; }
public String trimFrom ( CharSequence sequence ) { return sequence.toString ( ) ; }
public String trimLeadingFrom ( CharSequence sequence ) { return sequence.toString ( ) ; }
public String trimTrailingFrom ( CharSequence sequence ) { return sequence.toString ( ) ; }
public int countIn ( CharSequence sequence ) { checkNotNull ( sequence ) ; return 0 ; }
public CharMatcher and ( CharMatcher other ) { checkNotNull ( other ) ; return this ; }
public CharMatcher or ( CharMatcher other ) { return checkNotNull ( other ) ; }
public CharMatcher negate ( ) { return any ( ) ; }
public boolean matches ( char c ) { return TABLE.charAt ( ( MULTIPLIER * c ) > > > SHIFT ) == c ; }
void setBits ( BitSet table ) { for ( int i = 0 ; i < TABLE.length ( ) ; i++ ) { table.set ( TABLE.charAt ( i ) ) ; } }
public boolean matches ( char c ) { return c < = '\u007f' ; }
public boolean matches ( char c ) { int index = Arrays.binarySearch ( rangeStarts , c ) ; if ( index > = 0 ) { return true ; } else { index = ~index - 1 ; return index > = 0 && c < = rangeEnds[index] ; } }
private static char[] zeroes ( ) { return ZEROES.toCharArray ( ) ; }
private static char[] nines ( ) { char[] nines = new char[ZEROES.length ( ) ] ; for ( int i = 0 ; i < ZEROES.length ( ) ; i++ ) { nines[i] = ( char ) ( ZEROES.charAt ( i ) + 9 ) ; } return nines ; }
public boolean matches ( char c ) { return Character.isDigit ( c ) ; }
public boolean matches ( char c ) { return Character.isLetter ( c ) ; }
public boolean matches ( char c ) { return Character.isLetterOrDigit ( c ) ; }
public boolean matches ( char c ) { return Character.isUpperCase ( c ) ; }
public boolean matches ( char c ) { return Character.isLowerCase ( c ) ; }
public boolean matches ( char c ) { return c < = '\u001f' || ( c > = '\u007f' && c < = '\u009f' ) ; }
public boolean matches ( char c ) { return !original.matches ( c ) ; }
public boolean matchesAllOf ( CharSequence sequence ) { return original.matchesNoneOf ( sequence ) ; }
public boolean matchesNoneOf ( CharSequence sequence ) { return original.matchesAllOf ( sequence ) ; }
public int countIn ( CharSequence sequence ) { return sequence.length ( ) - original.countIn ( sequence ) ; }
void setBits ( BitSet table ) { BitSet tmp = new BitSet ( ) ; original.setBits ( tmp ) ; tmp.flip ( Character.MIN_VALUE , Character.MAX_VALUE + 1 ) ; table.or ( tmp ) ; }
public CharMatcher negate ( ) { return original ; }
public boolean matches ( char c ) { return first.matches ( c ) && second.matches ( c ) ; }
void setBits ( BitSet table ) { BitSet tmp1 = new BitSet ( ) ; first.setBits ( tmp1 ) ; BitSet tmp2 = new BitSet ( ) ; second.setBits ( tmp2 ) ; tmp1.and ( tmp2 ) ; table.or ( tmp1 ) ; }
void setBits ( BitSet table ) { first.setBits ( table ) ; second.setBits ( table ) ; }
public boolean matches ( char c ) { return first.matches ( c ) || second.matches ( c ) ; }
public boolean matches ( char c ) { return c == match ; }
public String replaceFrom ( CharSequence sequence , char replacement ) { return sequence.toString ( ) .replace ( match , replacement ) ; }
public CharMatcher and ( CharMatcher other ) { return other.matches ( match ) ? this : none ( ) ; }
public CharMatcher or ( CharMatcher other ) { return other.matches ( match ) ? other : super.or ( other ) ; }
public CharMatcher negate ( ) { return isNot ( match ) ; }
void setBits ( BitSet table ) { table.set ( match ) ; }
public boolean matches ( char c ) { return c != match ; }
public CharMatcher and ( CharMatcher other ) { return other.matches ( match ) ? super.and ( other ) : other ; }
public CharMatcher or ( CharMatcher other ) { return other.matches ( match ) ? any ( ) : this ; }
void setBits ( BitSet table ) { table.set ( 0 , match ) ; table.set ( match + 1 , Character.MAX_VALUE + 1 ) ; }
public CharMatcher negate ( ) { return is ( match ) ; }
private static CharMatcher.IsEither isEither ( char c1 , char c2 ) { return new CharMatcher.IsEither ( c1 , c2 ) ; }
public boolean matches ( char c ) { return c == match1 || c == match2 ; }
void setBits ( BitSet table ) { table.set ( match1 ) ; table.set ( match2 ) ; }
public boolean matches ( char c ) { return Arrays.binarySearch ( chars , c ) > = 0 ; }
void setBits ( BitSet table ) { for ( char c : chars ) { table.set ( c ) ; } }
public boolean matches ( char c ) { return startInclusive < = c && c < = endInclusive ; }
void setBits ( BitSet table ) { table.set ( startInclusive , endInclusive + 1 ) ; }
public boolean matches ( char c ) { return predicate.apply ( c ) ; }
public boolean apply ( Character character ) { return predicate.apply ( checkNotNull ( character ) ) ; }
public static CommonPattern compile ( String pattern ) { return Platform.compilePattern ( pattern ) ; }
public static boolean isPcreLike ( ) { return Platform.patternCompilerIsPcreLike ( ) ; }
public final B convert ( @Nullable A a ) { return correctedDoForward ( a ) ; }
B correctedDoForward ( @Nullable A a ) { if ( handleNullAutomatically ) { return a == null ? null : checkNotNull ( doForward ( a ) ) ; } else { return doForward ( a ) ; } }
A correctedDoBackward ( @Nullable B b ) { if ( handleNullAutomatically ) { return b == null ? null : checkNotNull ( doBackward ( b ) ) ; } else { return doBackward ( b ) ; } }
public boolean hasNext ( ) { return fromIterator.hasNext ( ) ; }
public B next ( ) { return convert ( fromIterator.next ( ) ) ; }
public void remove ( ) { fromIterator.remove ( ) ; }
public Converter < B , A > reverse ( ) { Converter < B , A > result = reverse ; return ( result == null ) ? reverse = new ReverseConverter < > ( this ) : result ; }
protected A doForward ( B b ) { throw new AssertionError ( ) ; }
protected B doBackward ( A a ) { throw new AssertionError ( ) ; }
A correctedDoForward ( @Nullable B b ) { return original.correctedDoBackward ( b ) ; }
B correctedDoBackward ( @Nullable A a ) { return original.correctedDoForward ( a ) ; }
public Converter < A , B > reverse ( ) { return original ; }
public final < C > Converter < A , C > andThen ( Converter < B , C > secondConverter ) { return doAndThen ( secondConverter ) ; }
 < C > Converter < A , C > doAndThen ( Converter < B , C > secondConverter ) { return new ConverterComposition < > ( this , checkNotNull ( secondConverter ) ) ; }
protected C doForward ( A a ) { throw new AssertionError ( ) ; }
protected A doBackward ( C c ) { throw new AssertionError ( ) ; }
C correctedDoForward ( @Nullable A a ) { return second.correctedDoForward ( first.correctedDoForward ( a ) ) ; }
A correctedDoBackward ( @Nullable C c ) { return first.correctedDoBackward ( second.correctedDoBackward ( c ) ) ; }
public final B apply ( @Nullable A a ) { return convert ( a ) ; }
public static < A , B > Converter < A , B > from ( Function < ? super A , ? extends B > forwardFunction , Function < ? super B , ? extends A > backwardFunction ) { return new FunctionBasedConverter < > ( forwardFunction , backwardFunction ) ; }
protected B doForward ( A a ) { return forwardFunction.apply ( a ) ; }
protected A doBackward ( B b ) { return backwardFunction.apply ( b ) ; }
public static < T > Converter < T , T > identity ( ) { return ( IdentityConverter < T > ) IdentityConverter.INSTANCE ; }
protected T doForward ( T t ) { return t ; }
protected T doBackward ( T t ) { return t ; }
public IdentityConverter < T > reverse ( ) { return this ; }
 < S > Converter < T , S > doAndThen ( Converter < T , S > otherConverter ) { return checkNotNull ( otherConverter , " otherConverter " ) ; }
public static Field getField ( Enum < ? > enumValue ) { Class < ? > clazz = enumValue.getDeclaringClass ( ) ; try { return clazz.getDeclaredField ( enumValue.name ( ) ) ; } catch ( NoSuchFieldException impossible ) { throw new AssertionError ( impossible ) ; } }
public static < T extends Enum < T > > Optional < T > getIfPresent ( Class < T > enumClass , String value ) { checkNotNull ( enumClass ) ; checkNotNull ( value ) ; return Platform.getEnumIfPresent ( enumClass , value ) ; }
private static < T extends Enum < T > > Map < String , WeakReference < ? extends Enum < ? > > > populateCache ( Class < T > enumClass ) { Map < String , WeakReference < ? extends Enum < ? > > > result = new HashMap < > ( ) ; for ( T enumInstance : EnumSet.allOf ( enumClass ) ) { result.put ( enumInstance.name ( ) , new WeakReference < Enum < ? > > ( enumInstance ) ) ; } enumConstantCache.put ( enumClass , result ) ; return result ; }
static < T extends Enum < T > > Map < String , WeakReference < ? extends Enum < ? > > > getEnumConstants ( Class < T > enumClass ) { synchronized ( enumConstantCache ) { Map < String , WeakReference < ? extends Enum < ? > > > constants = enumConstantCache.get ( enumClass ) ; if ( constants == null ) { constants = populateCache ( enumClass ) ; } return constants ; } }
public static < T extends Enum < T > > Converter < String , T > stringConverter ( final Class < T > enumClass ) { return new StringConverter < T > ( enumClass ) ; }
protected T doForward ( String value ) { return Enum.valueOf ( enumClass , value ) ; }
protected String doBackward ( T enumValue ) { return enumValue.name ( ) ; }
public final boolean equivalent ( @Nullable T a , @Nullable T b ) { if ( a == b ) { return true ; } if ( a == null || b == null ) { return false ; } return doEquivalent ( a , b ) ; }
public final boolean test ( @Nullable T t , @Nullable T u ) { return equivalent ( t , u ) ; }
public final int hash ( @Nullable T t ) { if ( t == null ) { return 0 ; } return doHash ( t ) ; }
public final < F > Equivalence < F > onResultOf ( Function < F , ? extends T > function ) { return new FunctionalEquivalence < > ( function , this ) ; }
public final < S extends T > Wrapper < S > wrap ( @Nullable S reference ) { return new Wrapper < S > ( this , reference ) ; }
public T get ( ) { return reference ; }
public final < S extends T > Equivalence < Iterable < S > > pairwise ( ) { return new PairwiseEquivalence < S > ( this ) ; }
public final Predicate < T > equivalentTo ( @Nullable T target ) { return new EquivalentToPredicate < T > ( this , target ) ; }
public boolean apply ( @Nullable T input ) { return equivalence.equivalent ( input , target ) ; }
public static Equivalence < Object > identity ( ) { return Identity.INSTANCE ; }
protected boolean doEquivalent ( Object a , Object b ) { return a.equals ( b ) ; }
protected int doHash ( Object o ) { return o.hashCode ( ) ; }
protected boolean doEquivalent ( Object a , Object b ) { return false ; }
protected int doHash ( Object o ) { return System.identityHashCode ( o ) ; }
public void close ( ) { frqRef.enqueue ( ) ; cleanUp ( ) ; }
private static Class < ? > loadFinalizer ( FinalizerLoader... loaders ) { for ( FinalizerLoader loader : loaders ) { Class < ? > finalizer = loader.loadFinalizer ( ) ; if ( finalizer != null ) { return finalizer ; } } throw new AssertionError ( ) ; }
URLClassLoader newLoader ( URL base ) { return new URLClassLoader ( new URL[] { base } , null ) ; }
public Class < ? > loadFinalizer ( ) { try { return Class.forName ( FINALIZER_CLASS_NAME ) ; } catch ( ClassNotFoundException e ) { throw new AssertionError ( e ) ; } }
static Method getStartFinalizer ( Class < ? > finalizer ) { try { return finalizer.getMethod ( " startFinalizer " , Class.class , ReferenceQueue.class , PhantomReference.class ) ; } catch ( NoSuchMethodException e ) { throw new AssertionError ( e ) ; } }
protected boolean doEquivalent ( F a , F b ) { return resultEquivalence.equivalent ( function.apply ( a ) , function.apply ( b ) ) ; }
protected int doHash ( F a ) { return resultEquivalence.hash ( function.apply ( a ) ) ; }
public static Function < Object , String > toStringFunction ( ) { return ToStringFunction.INSTANCE ; }
public String apply ( Object o ) { checkNotNull ( o ) ; return o.toString ( ) ; }
public static < E > Function < E , E > identity ( ) { return ( Function < E , E > ) IdentityFunction.INSTANCE ; }
public Object apply ( @Nullable Object o ) { return o ; }
public static < K , V > Function < K , V > forMap ( Map < K , V > map ) { return new FunctionForMapNoDefault < > ( map ) ; }
public static < K , V > Function < K , V > forMap ( Map < K , ? extends V > map , @Nullable V defaultValue ) { return new ForMapWithDefault < > ( map , defaultValue ) ; }
public V apply ( @Nullable K key ) { V result = map.get ( key ) ; checkArgument ( result != null || map.containsKey ( key ) , " Key '%s' not present in map " , key ) ; return result ; }
public V apply ( @Nullable K key ) { V result = map.get ( key ) ; return ( result != null || map.containsKey ( key ) ) ? result : defaultValue ; }
public static < A , B , C > Function < A , C > compose ( Function < B , C > g , Function < A , ? extends B > f ) { return new FunctionComposition < > ( g , f ) ; }
public C apply ( @Nullable A a ) { return g.apply ( f.apply ( a ) ) ; }
public static < T > Function < T , Boolean > forPredicate ( Predicate < T > predicate ) { return new PredicateFunction < T > ( predicate ) ; }
public Boolean apply ( @Nullable T t ) { return predicate.apply ( t ) ; }
public static < E > Function < Object , E > constant ( @Nullable E value ) { return new ConstantFunction < E > ( value ) ; }
public E apply ( @Nullable Object from ) { return value ; }
public static < T > Function < Object , T > forSupplier ( Supplier < T > supplier ) { return new SupplierFunction < T > ( supplier ) ; }
public T apply ( @Nullable Object input ) { return supplier.get ( ) ; }
public void run ( ) { while ( true ) { try { if ( !cleanUp ( queue.remove ( ) ) ) { break ; } } catch ( InterruptedException e ) { } } }
public CommonMatcher matcher ( CharSequence t ) { return new JdkMatcher ( pattern.matcher ( t ) ) ; }
public String pattern ( ) { return pattern.pattern ( ) ; }
public int flags ( ) { return pattern.flags ( ) ; }
public boolean matches ( ) { return matcher.matches ( ) ; }
public boolean find ( ) { return matcher.find ( ) ; }
public boolean find ( int index ) { return matcher.find ( index ) ; }
public String replaceAll ( String replacement ) { return matcher.replaceAll ( replacement ) ; }
public int end ( ) { return matcher.end ( ) ; }
public int start ( ) { return matcher.start ( ) ; }
public static Joiner on ( String separator ) { return new Joiner ( separator ) ; }
public static Joiner on ( char separator ) { return new Joiner ( String.valueOf ( separator ) ) ; }
public < A extends Appendable > A appendTo ( A appendable , Iterable < ? > parts ) throws IOException { return appendTo ( appendable , parts.iterator ( ) ) ; }
public < A extends Appendable > A appendTo ( A appendable , Iterator < ? > parts ) throws IOException { checkNotNull ( appendable ) ; if ( parts.hasNext ( ) ) { appendable.append ( toString ( parts.next ( ) ) ) ; while ( parts.hasNext ( ) ) { appendable.append ( separator ) ; appendable.append ( toString ( parts.next ( ) ) ) ; } } return appendable ; }
public final < A extends Appendable > A appendTo ( A appendable , Object[] parts ) throws IOException { return appendTo ( appendable , Arrays.asList ( parts ) ) ; }
public final StringBuilder appendTo ( StringBuilder builder , Iterable < ? > parts ) { return appendTo ( builder , parts.iterator ( ) ) ; }
public final StringBuilder appendTo ( StringBuilder builder , Iterator < ? > parts ) { try { appendTo ( ( Appendable ) builder , parts ) ; } catch ( IOException impossible ) { throw new AssertionError ( impossible ) ; } return builder ; }
public final StringBuilder appendTo ( StringBuilder builder , Object[] parts ) { return appendTo ( builder , Arrays.asList ( parts ) ) ; }
public final String join ( Iterable < ? > parts ) { return join ( parts.iterator ( ) ) ; }
public final String join ( Iterator < ? > parts ) { return appendTo ( new StringBuilder ( ) , parts ) .toString ( ) ; }
public final String join ( Object[] parts ) { return join ( Arrays.asList ( parts ) ) ; }
public Joiner useForNull ( String nullText ) { throw new UnsupportedOperationException ( " already specified useForNull " ) ; }
public Joiner skipNulls ( ) { throw new UnsupportedOperationException ( " already specified useForNull " ) ; }
public Joiner useForNull ( String nullText ) { throw new UnsupportedOperationException ( " already specified skipNulls " ) ; }
public MapJoiner withKeyValueSeparator ( String kvs ) { throw new UnsupportedOperationException ( " can't use .skipNulls ( ) with maps " ) ; }
public MapJoiner withKeyValueSeparator ( char keyValueSeparator ) { return withKeyValueSeparator ( String.valueOf ( keyValueSeparator ) ) ; }
public MapJoiner withKeyValueSeparator ( String keyValueSeparator ) { return new MapJoiner ( this , keyValueSeparator ) ; }
public < A extends Appendable > A appendTo ( A appendable , Map < ? , ? > map ) throws IOException { return appendTo ( appendable , map.entrySet ( ) ) ; }
public StringBuilder appendTo ( StringBuilder builder , Map < ? , ? > map ) { return appendTo ( builder , map.entrySet ( ) ) ; }
public < A extends Appendable > A appendTo ( A appendable , Iterable < ? extends Entry < ? , ? > > entries ) throws IOException { return appendTo ( appendable , entries.iterator ( ) ) ; }
public StringBuilder appendTo ( StringBuilder builder , Iterable < ? extends Entry < ? , ? > > entries ) { return appendTo ( builder , entries.iterator ( ) ) ; }
public StringBuilder appendTo ( StringBuilder builder , Iterator < ? extends Entry < ? , ? > > entries ) { try { appendTo ( ( Appendable ) builder , entries ) ; } catch ( IOException impossible ) { throw new AssertionError ( impossible ) ; } return builder ; }
public String join ( Map < ? , ? > map ) { return join ( map.entrySet ( ) ) ; }
public String join ( Iterable < ? extends Entry < ? , ? > > entries ) { return join ( entries.iterator ( ) ) ; }
public String join ( Iterator < ? extends Entry < ? , ? > > entries ) { return appendTo ( new StringBuilder ( ) , entries ) .toString ( ) ; }
public MapJoiner useForNull ( String nullText ) { return new MapJoiner ( joiner.useForNull ( nullText ) , keyValueSeparator ) ; }
public int size ( ) { return rest.length + 2 ; }
public static < T > T firstNonNull ( @Nullable T first , @Nullable T second ) { if ( first != null ) { return first ; } if ( second != null ) { return second ; } throw new NullPointerException ( " Both parameters are null " ) ; }
public static ToStringHelper toStringHelper ( Object self ) { return new ToStringHelper ( self.getClass ( ) .getSimpleName ( ) ) ; }
public static ToStringHelper toStringHelper ( Class < ? > clazz ) { return new ToStringHelper ( clazz.getSimpleName ( ) ) ; }
public static ToStringHelper toStringHelper ( String className ) { return new ToStringHelper ( className ) ; }
public ToStringHelper omitNullValues ( ) { omitNullValues = true ; return this ; }
public ToStringHelper add ( String name , @Nullable Object value ) { return addHolder ( name , value ) ; }
public ToStringHelper addValue ( @Nullable Object value ) { return addHolder ( value ) ; }
private ValueHolder addHolder ( ) { ValueHolder valueHolder = new ValueHolder ( ) ; holderTail = holderTail.next = valueHolder ; return valueHolder ; }
private ToStringHelper addHolder ( @Nullable Object value ) { ValueHolder valueHolder = addHolder ( ) ; valueHolder.value = value ; return this ; }
private ToStringHelper addHolder ( String name , @Nullable Object value ) { ValueHolder valueHolder = addHolder ( ) ; valueHolder.value = value ; valueHolder.name = checkNotNull ( name ) ; return this ; }
public static boolean equal ( @Nullable Object a , @Nullable Object b ) { return a == b || ( a != null && a.equals ( b ) ) ; }
public static < T > Optional < T > absent ( ) { return Absent.withType ( ) ; }
public static < T > Optional < T > of ( T reference ) { return new Present < T > ( checkNotNull ( reference ) ) ; }
public static < T > Optional < T > fromNullable ( @Nullable T nullableReference ) { return ( nullableReference == null ) ? Optional. < T > absent ( ) : new Present < T > ( nullableReference ) ; }
public static < T > Optional < T > fromJavaUtil ( java.util.@Nullable Optional < T > javaUtilOptional ) { return ( javaUtilOptional == null ) ? null : fromNullable ( javaUtilOptional.orElse ( null ) ) ; }
public static < T > java.util.@Nullable Optional < T > toJavaUtil ( @Nullable Optional < T > googleOptional ) { return googleOptional == null ? null : googleOptional.toJavaUtil ( ) ; }
public java.util.Optional < T > toJavaUtil ( ) { return java.util.Optional.ofNullable ( orNull ( ) ) ; }
protected T computeNext ( ) { while ( iterator.hasNext ( ) ) { Optional < ? extends T > optional = iterator.next ( ) ; if ( optional.isPresent ( ) ) { return optional.get ( ) ; } } return endOfData ( ) ; }
protected boolean doEquivalent ( Iterable < T > iterableA , Iterable < T > iterableB ) { Iterator < T > iteratorA = iterableA.iterator ( ) ; Iterator < T > iteratorB = iterableB.iterator ( ) ; while ( iteratorA.hasNext ( ) && iteratorB.hasNext ( ) ) { if ( !elementEquivalence.equivalent ( iteratorA.next ( ) , iteratorB.next ( ) ) ) { return false ; } } return !iteratorA.hasNext ( ) && !iteratorB.hasNext ( ) ; }
protected int doHash ( Iterable < T > iterable ) { int hash = 78721 ; for ( T element : iterable ) { hash = hash * 24943 + elementEquivalence.hash ( element ) ; } return hash ; }
static long systemNanoTime ( ) { return System.nanoTime ( ) ; }
static CharMatcher precomputeCharMatcher ( CharMatcher matcher ) { return matcher.precomputedInternal ( ) ; }
static < T extends Enum < T > > Optional < T > getEnumIfPresent ( Class < T > enumClass , String value ) { WeakReference < ? extends Enum < ? > > ref = Enums.getEnumConstants ( enumClass ) .get ( value ) ; return ref == null ? Optional. < T > absent ( ) : Optional.of ( enumClass.cast ( ref.get ( ) ) ) ; }
static String formatCompact4Digits ( double value ) { return String.format ( Locale.ROOT , " %.4g " , value ) ; }
static boolean stringIsNullOrEmpty ( @Nullable String string ) { return string == null || string.isEmpty ( ) ; }
static String nullToEmpty ( @Nullable String string ) { return ( string == null ) ? " " : string ; }
static String emptyToNull ( @Nullable String string ) { return stringIsNullOrEmpty ( string ) ? null : string ; }
static CommonPattern compilePattern ( String pattern ) { Preconditions.checkNotNull ( pattern ) ; return patternCompiler.compile ( pattern ) ; }
static boolean patternCompilerIsPcreLike ( ) { return patternCompiler.isPcreLike ( ) ; }
private static PatternCompiler loadPatternCompiler ( ) { return new JdkPatternCompiler ( ) ; }
private static void logPatternCompilerError ( ServiceConfigurationError e ) { logger.log ( Level.WARNING , " Error loading regex compiler , falling back to next option " , e ) ; }
public CommonPattern compile ( String pattern ) { return new JdkPattern ( Pattern.compile ( pattern ) ) ; }
public boolean isPcreLike ( ) { return true ; }
static void checkGwtRpcEnabled ( ) { if ( !parseBoolean ( System.getProperty ( GWT_RPC_PROPERTY_NAME , " true " ) ) ) { throw new UnsupportedOperationException ( lenientFormat ( " We are removing GWT-RPC support for Guava types. You can temporarily reenable " + " support by setting the system property %s to true. For more about system " + " properties , see %s. For more about Guava's GWT-RPC support , see %s. " , GWT_RPC_PROPERTY_NAME , " https://stackoverflow.com/q/5189914/28465 " , " https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ " ) ) ; } }
public static void checkArgument ( boolean expression ) { if ( !expression ) { throw new IllegalArgumentException ( ) ; } }
public static void checkArgument ( boolean expression , @Nullable Object errorMessage ) { if ( !expression ) { throw new IllegalArgumentException ( String.valueOf ( errorMessage ) ) ; } }
public static void checkArgument ( boolean expression , @Nullable String errorMessageTemplate , @Nullable Object@Nullable ... errorMessageArgs ) { if ( !expression ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , errorMessageArgs ) ) ; } }
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , char p1 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } }
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , int p1 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } }
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , long p1 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } }
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , @Nullable Object p1 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } }
public static void checkState ( boolean expression ) { if ( !expression ) { throw new IllegalStateException ( ) ; } }
public static void checkState ( boolean expression , @Nullable Object errorMessage ) { if ( !expression ) { throw new IllegalStateException ( String.valueOf ( errorMessage ) ) ; } }
public static < T extends @NonNull Object > T checkNotNull ( T reference ) { if ( reference == null ) { throw new NullPointerException ( ) ; } return reference ; }
public static < T extends @NonNull Object > T checkNotNull ( T reference , @Nullable Object errorMessage ) { if ( reference == null ) { throw new NullPointerException ( String.valueOf ( errorMessage ) ) ; } return reference ; }
public static int checkElementIndex ( int index , int size ) { return checkElementIndex ( index , size , " index " ) ; }
public static int checkElementIndex ( int index , int size , @Nullable String desc ) { if ( index < 0 || index > = size ) { throw new IndexOutOfBoundsException ( badElementIndex ( index , size , desc ) ) ; } return index ; }
public static int checkPositionIndex ( int index , int size ) { return checkPositionIndex ( index , size , " index " ) ; }
public static int checkPositionIndex ( int index , int size , @Nullable String desc ) { if ( index < 0 || index > size ) { throw new IndexOutOfBoundsException ( badPositionIndex ( index , size , desc ) ) ; } return index ; }
public static void checkPositionIndexes ( int start , int end , int size ) { if ( start < 0 || end < start || end > size ) { throw new IndexOutOfBoundsException ( badPositionIndexes ( start , end , size ) ) ; } }
default boolean test ( @Nullable T input ) { return apply ( input ) ; }
public static < T > Predicate < T > alwaysTrue ( ) { return ObjectPredicate.ALWAYS_TRUE.withNarrowedType ( ) ; }
public static < T > Predicate < T > alwaysFalse ( ) { return ObjectPredicate.ALWAYS_FALSE.withNarrowedType ( ) ; }
public static < T > Predicate < T > isNull ( ) { return ObjectPredicate.IS_NULL.withNarrowedType ( ) ; }
public static < T > Predicate < T > notNull ( ) { return ObjectPredicate.NOT_NULL.withNarrowedType ( ) ; }
public static < T > Predicate < T > not ( Predicate < T > predicate ) { return new NotPredicate < T > ( predicate ) ; }
public static < T > Predicate < T > and ( Iterable < ? extends Predicate < ? super T > > components ) { return new AndPredicate < T > ( defensiveCopy ( components ) ) ; }
public static < T > Predicate < T > and ( Predicate < ? super T > ... components ) { return new AndPredicate < T > ( defensiveCopy ( components ) ) ; }
public static < T > Predicate < T > and ( Predicate < ? super T > first , Predicate < ? super T > second ) { return new AndPredicate < T > ( Predicates. < T > asList ( checkNotNull ( first ) , checkNotNull ( second ) ) ) ; }
public static < T > Predicate < T > or ( Iterable < ? extends Predicate < ? super T > > components ) { return new OrPredicate < T > ( defensiveCopy ( components ) ) ; }
public static < T > Predicate < T > or ( Predicate < ? super T > ... components ) { return new OrPredicate < T > ( defensiveCopy ( components ) ) ; }
public static < T > Predicate < T > or ( Predicate < ? super T > first , Predicate < ? super T > second ) { return new OrPredicate < T > ( Predicates. < T > asList ( checkNotNull ( first ) , checkNotNull ( second ) ) ) ; }
public static < T > Predicate < T > equalTo ( @Nullable T target ) { return ( target == null ) ? Predicates. < T > isNull ( ) : new IsEqualToPredicate < T > ( target ) ; }
public static Predicate < Object > instanceOf ( Class < ? > clazz ) { return new InstanceOfPredicate ( clazz ) ; }
public static Predicate < Class < ? > > subtypeOf ( Class < ? > clazz ) { return new SubtypeOfPredicate ( clazz ) ; }
public static < T > Predicate < T > in ( Collection < ? extends T > target ) { return new InPredicate < T > ( target ) ; }
public static < A , B > Predicate < A > compose ( Predicate < B > predicate , Function < A , ? extends B > function ) { return new CompositionPredicate < > ( predicate , function ) ; }
public static Predicate < CharSequence > containsPattern ( String pattern ) { return new ContainsPatternFromStringPredicate ( pattern ) ; }
public static Predicate < CharSequence > contains ( Pattern pattern ) { return new ContainsPatternPredicate ( new JdkPattern ( pattern ) ) ; }
 < T > Predicate < T > withNarrowedType ( ) { return ( Predicate < T > ) this ; }
public boolean apply ( @Nullable Object o ) { return true ; }
public boolean apply ( @Nullable T t ) { return !predicate.apply ( t ) ; }
public boolean apply ( @Nullable T t ) { for ( int i = 0 ; i < components.size ( ) ; i++ ) { if ( !components.get ( i ) .apply ( t ) ) { return false ; } } return true ; }
public boolean apply ( T t ) { return target.equals ( t ) ; }
private static < T > List < Predicate < ? super T > > asList ( Predicate < ? super T > first , Predicate < ? super T > second ) { return Arrays. < Predicate < ? super T > > asList ( first , second ) ; }
private static < T > List < T > defensiveCopy ( T... array ) { return defensiveCopy ( Arrays.asList ( array ) ) ; }
static < T > List < T > defensiveCopy ( Iterable < T > iterable ) { ArrayList < T > list = new ArrayList < T > ( ) ; for ( T element : iterable ) { list.add ( checkNotNull ( element ) ) ; } return list ; }
public boolean isPresent ( ) { return true ; }
public T or ( T defaultValue ) { checkNotNull ( defaultValue , " use Optional.orNull ( ) instead of Optional.or ( null ) " ) ; return reference ; }
public Optional < T > or ( Optional < ? extends T > secondChoice ) { checkNotNull ( secondChoice ) ; return this ; }
public T or ( Supplier < ? extends T > supplier ) { checkNotNull ( supplier ) ; return reference ; }
public T orNull ( ) { return reference ; }
public Set < T > asSet ( ) { return Collections.singleton ( reference ) ; }
public < V > Optional < V > transform ( Function < ? super T , V > function ) { return new Present < V > ( checkNotNull ( function.apply ( reference ) , " the Function passed to Optional.transform ( ) must not return null. " ) ) ; }
static int smear ( int hashCode ) { return C2 * Integer.rotateLeft ( hashCode * C1 , 15 ) ; }
private boolean checkFilter ( int c ) { return 1 == ( 1 & ( filter > > c ) ) ; }
static int chooseTableSize ( int setSize ) { if ( setSize == 1 ) { return 2 ; } int tableSize = Integer.highestOneBit ( setSize - 1 ) < < 1 ; while ( tableSize * DESIRED_LOAD_FACTOR < setSize ) { tableSize < < = 1 ; } return tableSize ; }
void setBits ( BitSet table ) { if ( containsZero ) { table.set ( 0 ) ; } for ( char c : this.table ) { if ( c != 0 ) { table.set ( c ) ; } } }
public static Splitter on ( char separator ) { return on ( CharMatcher.is ( separator ) ) ; }
int separatorStart ( int start ) { return separatorMatcher.indexIn ( toSplit , start ) ; }
int separatorEnd ( int separatorPosition ) { return separatorPosition + 1 ; }
public int separatorStart ( int start ) { int separatorLength = separator.length ( ) ; positions: for ( int p = start , last = toSplit.length ( ) - separatorLength ; p < = last ; p++ ) { for ( int i = 0 ; i < separatorLength ; i++ ) { if ( toSplit.charAt ( i + p ) != separator.charAt ( i ) ) { continue positions ; } } return p ; } return -1 ; }
public int separatorEnd ( int separatorPosition ) { return separatorPosition + separator.length ( ) ; }
public static Splitter on ( Pattern separatorPattern ) { return on ( new JdkPattern ( separatorPattern ) ) ; }
public int separatorStart ( int start ) { return matcher.find ( start ) ? matcher.start ( ) : -1 ; }
public int separatorEnd ( int separatorPosition ) { return matcher.end ( ) ; }
public static Splitter onPattern ( String separatorPattern ) { return on ( Platform.compilePattern ( separatorPattern ) ) ; }
public int separatorStart ( int start ) { int nextChunkStart = start + length ; return ( nextChunkStart < toSplit.length ( ) ? nextChunkStart : -1 ) ; }
public int separatorEnd ( int separatorPosition ) { return separatorPosition ; }
public Splitter omitEmptyStrings ( ) { return new Splitter ( strategy , true , trimmer , limit ) ; }
public Splitter limit ( int maxItems ) { checkArgument ( maxItems > 0 , " must be greater than zero: %s " , maxItems ) ; return new Splitter ( strategy , omitEmptyStrings , trimmer , maxItems ) ; }
public Splitter trimResults ( ) { return trimResults ( CharMatcher.whitespace ( ) ) ; }
public Splitter trimResults ( CharMatcher trimmer ) { checkNotNull ( trimmer ) ; return new Splitter ( strategy , omitEmptyStrings , trimmer , limit ) ; }
public Iterator < String > iterator ( ) { return splittingIterator ( sequence ) ; }
private Iterator < String > splittingIterator ( CharSequence sequence ) { return strategy.iterator ( this , sequence ) ; }
public List < String > splitToList ( CharSequence sequence ) { checkNotNull ( sequence ) ; Iterator < String > iterator = splittingIterator ( sequence ) ; List < String > result = new ArrayList < > ( ) ; while ( iterator.hasNext ( ) ) { result.add ( iterator.next ( ) ) ; } return Collections.unmodifiableList ( result ) ; }
public MapSplitter withKeyValueSeparator ( String separator ) { return withKeyValueSeparator ( on ( separator ) ) ; }
public MapSplitter withKeyValueSeparator ( char separator ) { return withKeyValueSeparator ( on ( separator ) ) ; }
public MapSplitter withKeyValueSeparator ( Splitter keyValueSplitter ) { return new MapSplitter ( this , keyValueSplitter ) ; }
public String key ( ) { return key ; }
public String value ( ) { return System.getProperty ( key ) ; }
public static Stopwatch createUnstarted ( ) { return new Stopwatch ( ) ; }
public static Stopwatch createUnstarted ( Ticker ticker ) { return new Stopwatch ( ticker ) ; }
public static Stopwatch createStarted ( ) { return new Stopwatch ( ) .start ( ) ; }
public static Stopwatch createStarted ( Ticker ticker ) { return new Stopwatch ( ticker ) .start ( ) ; }
public boolean isRunning ( ) { return isRunning ; }
public Stopwatch start ( ) { checkState ( !isRunning , " This stopwatch is already running. " ) ; isRunning = true ; startTick = ticker.read ( ) ; return this ; }
public Stopwatch stop ( ) { long tick = ticker.read ( ) ; checkState ( isRunning , " This stopwatch is already stopped. " ) ; isRunning = false ; elapsedNanos += tick - startTick ; return this ; }
public Stopwatch reset ( ) { elapsedNanos = 0 ; isRunning = false ; return this ; }
private long elapsedNanos ( ) { return isRunning ? ticker.read ( ) - startTick + elapsedNanos : elapsedNanos ; }
public long elapsed ( TimeUnit desiredUnit ) { return desiredUnit.convert ( elapsedNanos ( ) , NANOSECONDS ) ; }
public Duration elapsed ( ) { return Duration.ofNanos ( elapsedNanos ( ) ) ; }
public static String nullToEmpty ( @Nullable String string ) { return Platform.nullToEmpty ( string ) ; }
public static String emptyToNull ( @Nullable String string ) { return Platform.emptyToNull ( string ) ; }
public static boolean isNullOrEmpty ( @Nullable String string ) { return Platform.stringIsNullOrEmpty ( string ) ; }
public static String padStart ( String string , int minLength , char padChar ) { checkNotNull ( string ) ; if ( string.length ( ) > = minLength ) { return string ; } StringBuilder sb = new StringBuilder ( minLength ) ; for ( int i = string.length ( ) ; i < minLength ; i++ ) { sb.append ( padChar ) ; } sb.append ( string ) ; return sb.toString ( ) ; }
public static String padEnd ( String string , int minLength , char padChar ) { checkNotNull ( string ) ; if ( string.length ( ) > = minLength ) { return string ; } StringBuilder sb = new StringBuilder ( minLength ) ; sb.append ( string ) ; for ( int i = string.length ( ) ; i < minLength ; i++ ) { sb.append ( padChar ) ; } return sb.toString ( ) ; }
public static String commonPrefix ( CharSequence a , CharSequence b ) { checkNotNull ( a ) ; checkNotNull ( b ) ; int maxPrefixLength = Math.min ( a.length ( ) , b.length ( ) ) ; int p = 0 ; while ( p < maxPrefixLength && a.charAt ( p ) == b.charAt ( p ) ) { p++ ; } if ( validSurrogatePairAt ( a , p - 1 ) || validSurrogatePairAt ( b , p - 1 ) ) { p-- ; } return a.subSequence ( 0 , p ) .toString ( ) ; }
public static String commonSuffix ( CharSequence a , CharSequence b ) { checkNotNull ( a ) ; checkNotNull ( b ) ; int maxSuffixLength = Math.min ( a.length ( ) , b.length ( ) ) ; int s = 0 ; while ( s < maxSuffixLength && a.charAt ( a.length ( ) - s - 1 ) == b.charAt ( b.length ( ) - s - 1 ) ) { s++ ; } if ( validSurrogatePairAt ( a , a.length ( ) - s - 1 ) || validSurrogatePairAt ( b , b.length ( ) - s - 1 ) ) { s-- ; } return a.subSequence ( a.length ( ) - s , a.length ( ) ) .toString ( ) ; }
static boolean validSurrogatePairAt ( CharSequence string , int index ) { return index > = 0 && index < = ( string.length ( ) - 2 ) && Character.isHighSurrogate ( string.charAt ( index ) ) && Character.isLowSurrogate ( string.charAt ( index + 1 ) ) ; }
private static String lenientToString ( @Nullable Object o ) { try { return String.valueOf ( o ) ; } catch ( Exception e ) { String objectToString = o.getClass ( ) .getName ( ) + '@' + Integer.toHexString ( System.identityHashCode ( o ) ) ; Logger.getLogger ( " com.google.common.base.Strings " ) .log ( WARNING , " Exception during lenientFormat for " + objectToString , e ) ; return " < " + objectToString + " threw " + e.getClass ( ) .getName ( ) + " > " ; } }
public static < F , T > Supplier < T > compose ( Function < ? super F , T > function , Supplier < F > supplier ) { return new SupplierComposition < > ( function , supplier ) ; }
public T get ( ) { return function.apply ( supplier.get ( ) ) ; }
public static < T > Supplier < T > memoize ( Supplier < T > delegate ) { if ( delegate instanceof NonSerializableMemoizingSupplier || delegate instanceof MemoizingSupplier ) { return delegate ; } return delegate instanceof Serializable ? new MemoizingSupplier < T > ( delegate ) : new NonSerializableMemoizingSupplier < T > ( delegate ) ; }
public T get ( ) { if ( !initialized ) { synchronized ( this ) { if ( !initialized ) { T t = delegate.get ( ) ; value = t ; initialized = true ; return t ; } } } return value ; }
public static < T > Supplier < T > memoizeWithExpiration ( Supplier < T > delegate , long duration , TimeUnit unit ) { return new ExpiringMemoizingSupplier < T > ( delegate , duration , unit ) ; }
public static < T > Supplier < T > ofInstance ( @Nullable T instance ) { return new SupplierOfInstance < T > ( instance ) ; }
public T get ( ) { return instance ; }
public static < T > Supplier < T > synchronizedSupplier ( Supplier < T > delegate ) { return new ThreadSafeSupplier < T > ( delegate ) ; }
public T get ( ) { synchronized ( delegate ) { return delegate.get ( ) ; } }
public static < T > Function < Supplier < T > , T > supplierFunction ( ) { @SuppressWarnings ( " unchecked " ) SupplierFunction < T > sf = ( SupplierFunction < T > ) SupplierFunctionImpl.INSTANCE ; return sf ; }
public Object apply ( Supplier < Object > input ) { return input.get ( ) ; }
public static < X extends Throwable > void throwIfInstanceOf ( Throwable throwable , Class < X > declaredType ) throws X { checkNotNull ( throwable ) ; if ( declaredType.isInstance ( throwable ) ) { throw declaredType.cast ( throwable ) ; } }
public static < X extends Throwable > void propagateIfInstanceOf ( @Nullable Throwable throwable , Class < X > declaredType ) throws X { if ( throwable != null ) { throwIfInstanceOf ( throwable , declaredType ) ; } }
public static void throwIfUnchecked ( Throwable throwable ) { checkNotNull ( throwable ) ; if ( throwable instanceof RuntimeException ) { throw ( RuntimeException ) throwable ; } if ( throwable instanceof Error ) { throw ( Error ) throwable ; } }
public static void propagateIfPossible ( @Nullable Throwable throwable ) { if ( throwable != null ) { throwIfUnchecked ( throwable ) ; } }
public static < X extends Throwable > void propagateIfPossible ( @Nullable Throwable throwable , Class < X > declaredType ) throws X { propagateIfInstanceOf ( throwable , declaredType ) ; propagateIfPossible ( throwable ) ; }
public static RuntimeException propagate ( Throwable throwable ) { throwIfUnchecked ( throwable ) ; throw new RuntimeException ( throwable ) ; }
public static < X extends Throwable > X getCauseAs ( Throwable throwable , Class < X > expectedCauseType ) { try { return expectedCauseType.cast ( throwable.getCause ( ) ) ; } catch ( ClassCastException e ) { e.initCause ( throwable ) ; throw e ; } }
public static String getStackTraceAsString ( Throwable throwable ) { StringWriter stringWriter = new StringWriter ( ) ; throwable.printStackTrace ( new PrintWriter ( stringWriter ) ) ; return stringWriter.toString ( ) ; }
public static List < StackTraceElement > lazyStackTrace ( Throwable throwable ) { return lazyStackTraceIsLazy ( ) ? jlaStackTrace ( throwable ) : unmodifiableList ( asList ( throwable.getStackTrace ( ) ) ) ; }
public static boolean lazyStackTraceIsLazy ( ) { return getStackTraceElementMethod != null && getStackTraceDepthMethod != null ; }
public StackTraceElement get ( int n ) { return ( StackTraceElement ) invokeAccessibleNonThrowingMethod ( getStackTraceElementMethod , jla , t , n ) ; }
public int size ( ) { return ( Integer ) invokeAccessibleNonThrowingMethod ( getStackTraceDepthMethod , jla , t ) ; }
private static Method getGetMethod ( ) { return getJlaMethod ( " getStackTraceElement " , Throwable.class , int.class ) ; }
public static Ticker systemTicker ( ) { return SYSTEM_TICKER ; }
public long read ( ) { return Platform.systemNanoTime ( ) ; }
public static boolean isWellFormed ( byte[] bytes ) { return isWellFormed ( bytes , 0 , bytes.length ) ; }
public static boolean isWellFormed ( byte[] bytes , int off , int len ) { int end = off + len ; checkPositionIndexes ( off , end , bytes.length ) ; for ( int i = off ; i < end ; i++ ) { if ( bytes[i] < 0 ) { return isWellFormedSlowPath ( bytes , i , end ) ; } } return true ; }
private static String unpairedSurrogateMsg ( int i ) { return " Unpaired surrogate at index " + i ; }
public static void verify ( boolean expression ) { if ( !expression ) { throw new VerifyException ( ) ; } }
public static < T > T verifyNotNull ( @Nullable T reference ) { return verifyNotNull ( reference , " expected a non-null reference " ) ; }
public void putAll ( Map < ? extends K , ? extends V > m ) { for ( Entry < ? extends K , ? extends V > entry : m.entrySet ( ) ) { put ( entry.getKey ( ) , entry.getValue ( ) ) ; } }
public void invalidateAll ( Iterable < ? > keys ) { for ( Object key : keys ) { invalidate ( key ) ; } }
public void recordHits ( int count ) { hitCount.add ( count ) ; }
public void recordMisses ( int count ) { missCount.add ( count ) ; }
public void recordLoadSuccess ( long loadTime ) { loadSuccessCount.increment ( ) ; totalLoadTime.add ( loadTime ) ; }
public void recordLoadException ( long loadTime ) { loadExceptionCount.increment ( ) ; totalLoadTime.add ( loadTime ) ; }
public void recordEviction ( ) { evictionCount.increment ( ) ; }
public CacheStats snapshot ( ) { return new CacheStats ( negativeToMaxValue ( hitCount.sum ( ) ) , negativeToMaxValue ( missCount.sum ( ) ) , negativeToMaxValue ( loadSuccessCount.sum ( ) ) , negativeToMaxValue ( loadExceptionCount.sum ( ) ) , negativeToMaxValue ( totalLoadTime.sum ( ) ) , negativeToMaxValue ( evictionCount.sum ( ) ) ) ; }
private static long negativeToMaxValue ( long value ) { return ( value > = 0 ) ? value : Long.MAX_VALUE ; }
public void incrementBy ( StatsCounter other ) { CacheStats otherStats = other.snapshot ( ) ; hitCount.add ( otherStats.hitCount ( ) ) ; missCount.add ( otherStats.missCount ( ) ) ; loadSuccessCount.add ( otherStats.loadSuccessCount ( ) ) ; loadExceptionCount.add ( otherStats.loadExceptionCount ( ) ) ; totalLoadTime.add ( otherStats.totalLoadTime ( ) ) ; evictionCount.add ( otherStats.evictionCount ( ) ) ; }
public V getUnchecked ( K key ) { try { return get ( key ) ; } catch ( ExecutionException e ) { throw new UncheckedExecutionException ( e.getCause ( ) ) ; } }
public ImmutableMap < K , V > getAll ( Iterable < ? extends K > keys ) throws ExecutionException { Map < K , V > result = Maps.newLinkedHashMap ( ) ; for ( K key : keys ) { if ( !result.containsKey ( key ) ) { result.put ( key , get ( key ) ) ; } } return ImmutableMap.copyOf ( result ) ; }
public final V apply ( K key ) { return getUnchecked ( key ) ; }
public CacheStats snapshot ( ) { return EMPTY_STATS ; }
public StatsCounter get ( ) { return new SimpleStatsCounter ( ) ; }
public int weigh ( Object key , Object value ) { return 1 ; }
public long read ( ) { return 0 ; }
public static CacheBuilder < Object , Object > newBuilder ( ) { return new CacheBuilder < > ( ) ; }
public static CacheBuilder < Object , Object > from ( CacheBuilderSpec spec ) { return spec.toCacheBuilder ( ) .lenientParsing ( ) ; }
public static CacheBuilder < Object , Object > from ( String spec ) { return from ( CacheBuilderSpec.parse ( spec ) ) ; }
CacheBuilder < K , V > lenientParsing ( ) { strictParsing = false ; return this ; }
CacheBuilder < K , V > keyEquivalence ( Equivalence < Object > equivalence ) { checkState ( keyEquivalence == null , " key equivalence was already set to %s " , keyEquivalence ) ; keyEquivalence = checkNotNull ( equivalence ) ; return this ; }
Equivalence < Object > getKeyEquivalence ( ) { return MoreObjects.firstNonNull ( keyEquivalence , getKeyStrength ( ) .defaultEquivalence ( ) ) ; }
CacheBuilder < K , V > valueEquivalence ( Equivalence < Object > equivalence ) { checkState ( valueEquivalence == null , " value equivalence was already set to %s " , valueEquivalence ) ; this.valueEquivalence = checkNotNull ( equivalence ) ; return this ; }
Equivalence < Object > getValueEquivalence ( ) { return MoreObjects.firstNonNull ( valueEquivalence , getValueStrength ( ) .defaultEquivalence ( ) ) ; }
public CacheBuilder < K , V > initialCapacity ( int initialCapacity ) { checkState ( this.initialCapacity == UNSET_INT , " initial capacity was already set to %s " , this.initialCapacity ) ; checkArgument ( initialCapacity > = 0 ) ; this.initialCapacity = initialCapacity ; return this ; }
int getInitialCapacity ( ) { return ( initialCapacity == UNSET_INT ) ? DEFAULT_INITIAL_CAPACITY : initialCapacity ; }
public CacheBuilder < K , V > concurrencyLevel ( int concurrencyLevel ) { checkState ( this.concurrencyLevel == UNSET_INT , " concurrency level was already set to %s " , this.concurrencyLevel ) ; checkArgument ( concurrencyLevel > 0 ) ; this.concurrencyLevel = concurrencyLevel ; return this ; }
int getConcurrencyLevel ( ) { return ( concurrencyLevel == UNSET_INT ) ? DEFAULT_CONCURRENCY_LEVEL : concurrencyLevel ; }
public CacheBuilder < K , V > maximumSize ( long maximumSize ) { checkState ( this.maximumSize == UNSET_INT , " maximum size was already set to %s " , this.maximumSize ) ; checkState ( this.maximumWeight == UNSET_INT , " maximum weight was already set to %s " , this.maximumWeight ) ; checkState ( this.weigher == null , " maximum size can not be combined with weigher " ) ; checkArgument ( maximumSize > = 0 , " maximum size must not be negative " ) ; this.maximumSize = maximumSize ; return this ; }
public CacheBuilder < K , V > maximumWeight ( long maximumWeight ) { checkState ( this.maximumWeight == UNSET_INT , " maximum weight was already set to %s " , this.maximumWeight ) ; checkState ( this.maximumSize == UNSET_INT , " maximum size was already set to %s " , this.maximumSize ) ; this.maximumWeight = maximumWeight ; checkArgument ( maximumWeight > = 0 , " maximum weight must not be negative " ) ; return this ; }
public < K1 extends K , V1 extends V > CacheBuilder < K1 , V1 > weigher ( Weigher < ? super K1 , ? super V1 > weigher ) { checkState ( this.weigher == null ) ; if ( strictParsing ) { checkState ( this.maximumSize == UNSET_INT , " weigher can not be combined with maximum size " , this.maximumSize ) ; } @SuppressWarnings ( " unchecked " ) CacheBuilder < K1 , V1 > me = ( CacheBuilder < K1 , V1 > ) this ; me.weigher = checkNotNull ( weigher ) ; return me ; }
long getMaximumWeight ( ) { if ( expireAfterWriteNanos == 0 || expireAfterAccessNanos == 0 ) { return 0 ; } return ( weigher == null ) ? maximumSize : maximumWeight ; }
 < K1 extends K , V1 extends V > Weigher < K1 , V1 > getWeigher ( ) { return ( Weigher < K1 , V1 > ) MoreObjects.firstNonNull ( weigher , OneWeigher.INSTANCE ) ; }
public CacheBuilder < K , V > weakKeys ( ) { return setKeyStrength ( Strength.WEAK ) ; }
CacheBuilder < K , V > setKeyStrength ( Strength strength ) { checkState ( keyStrength == null , " Key strength was already set to %s " , keyStrength ) ; keyStrength = checkNotNull ( strength ) ; return this ; }
Strength getKeyStrength ( ) { return MoreObjects.firstNonNull ( keyStrength , Strength.STRONG ) ; }
public CacheBuilder < K , V > weakValues ( ) { return setValueStrength ( Strength.WEAK ) ; }
public CacheBuilder < K , V > softValues ( ) { return setValueStrength ( Strength.SOFT ) ; }
CacheBuilder < K , V > setValueStrength ( Strength strength ) { checkState ( valueStrength == null , " Value strength was already set to %s " , valueStrength ) ; valueStrength = checkNotNull ( strength ) ; return this ; }
Strength getValueStrength ( ) { return MoreObjects.firstNonNull ( valueStrength , Strength.STRONG ) ; }
public CacheBuilder < K , V > expireAfterWrite ( java.time.Duration duration ) { return expireAfterWrite ( saturatedToNanos ( duration ) , TimeUnit.NANOSECONDS ) ; }
public CacheBuilder < K , V > expireAfterWrite ( long duration , TimeUnit unit ) { checkState ( expireAfterWriteNanos == UNSET_INT , " expireAfterWrite was already set to %s ns " , expireAfterWriteNanos ) ; checkArgument ( duration > = 0 , " duration cannot be negative: %s %s " , duration , unit ) ; this.expireAfterWriteNanos = unit.toNanos ( duration ) ; return this ; }
long getExpireAfterWriteNanos ( ) { return ( expireAfterWriteNanos == UNSET_INT ) ? DEFAULT_EXPIRATION_NANOS : expireAfterWriteNanos ; }
public CacheBuilder < K , V > expireAfterAccess ( java.time.Duration duration ) { return expireAfterAccess ( saturatedToNanos ( duration ) , TimeUnit.NANOSECONDS ) ; }
public CacheBuilder < K , V > expireAfterAccess ( long duration , TimeUnit unit ) { checkState ( expireAfterAccessNanos == UNSET_INT , " expireAfterAccess was already set to %s ns " , expireAfterAccessNanos ) ; checkArgument ( duration > = 0 , " duration cannot be negative: %s %s " , duration , unit ) ; this.expireAfterAccessNanos = unit.toNanos ( duration ) ; return this ; }
long getExpireAfterAccessNanos ( ) { return ( expireAfterAccessNanos == UNSET_INT ) ? DEFAULT_EXPIRATION_NANOS : expireAfterAccessNanos ; }
public CacheBuilder < K , V > refreshAfterWrite ( java.time.Duration duration ) { return refreshAfterWrite ( saturatedToNanos ( duration ) , TimeUnit.NANOSECONDS ) ; }
public CacheBuilder < K , V > refreshAfterWrite ( long duration , TimeUnit unit ) { checkNotNull ( unit ) ; checkState ( refreshNanos == UNSET_INT , " refresh was already set to %s ns " , refreshNanos ) ; checkArgument ( duration > 0 , " duration must be positive: %s %s " , duration , unit ) ; this.refreshNanos = unit.toNanos ( duration ) ; return this ; }
long getRefreshNanos ( ) { return ( refreshNanos == UNSET_INT ) ? DEFAULT_REFRESH_NANOS : refreshNanos ; }
public CacheBuilder < K , V > ticker ( Ticker ticker ) { checkState ( this.ticker == null ) ; this.ticker = checkNotNull ( ticker ) ; return this ; }
Ticker getTicker ( boolean recordsTime ) { if ( ticker != null ) { return ticker ; } return recordsTime ? Ticker.systemTicker ( ) : NULL_TICKER ; }
public < K1 extends K , V1 extends V > CacheBuilder < K1 , V1 > removalListener ( RemovalListener < ? super K1 , ? super V1 > listener ) { checkState ( this.removalListener == null ) ; @SuppressWarnings ( " unchecked " ) CacheBuilder < K1 , V1 > me = ( CacheBuilder < K1 , V1 > ) this ; me.removalListener = checkNotNull ( listener ) ; return me ; }
 < K1 extends K , V1 extends V > RemovalListener < K1 , V1 > getRemovalListener ( ) { return ( RemovalListener < K1 , V1 > ) MoreObjects.firstNonNull ( removalListener , NullListener.INSTANCE ) ; }
public CacheBuilder < K , V > recordStats ( ) { statsCounterSupplier = CACHE_STATS_COUNTER ; return this ; }
boolean isRecordingStats ( ) { return statsCounterSupplier == CACHE_STATS_COUNTER ; }
Supplier < ? extends StatsCounter > getStatsCounterSupplier ( ) { return statsCounterSupplier ; }
public < K1 extends K , V1 extends V > LoadingCache < K1 , V1 > build ( CacheLoader < ? super K1 , V1 > loader ) { checkWeightWithWeigher ( ) ; return new LocalCache.LocalLoadingCache < > ( this , loader ) ; }
public < K1 extends K , V1 extends V > Cache < K1 , V1 > build ( ) { checkWeightWithWeigher ( ) ; checkNonLoadingCache ( ) ; return new LocalCache.LocalManualCache < > ( this ) ; }
private void checkNonLoadingCache ( ) { checkState ( refreshNanos == UNSET_INT , " refreshAfterWrite requires a LoadingCache " ) ; }
private static long saturatedToNanos ( java.time.Duration duration ) { try { return duration.toNanos ( ) ; } catch ( ArithmeticException tooBig ) { return duration.isNegative ( ) ? Long.MIN_VALUE : Long.MAX_VALUE ; } }
public static CacheBuilderSpec disableCaching ( ) { return CacheBuilderSpec.parse ( " maximumSize=0 " ) ; }
public String toParsableString ( ) { return specification ; }
private static Long durationInNanos ( long duration , @Nullable TimeUnit unit ) { return ( unit == null ) ? null : unit.toNanos ( duration ) ; }
public void parse ( CacheBuilderSpec spec , String key , String value ) { checkArgument ( value != null && !value.isEmpty ( ) , " value of key %s omitted " , key ) ; try { parseInteger ( spec , Integer.parseInt ( value ) ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( format ( " key %s value set to %s , must be integer " , key , value ) , e ) ; } }
public void parse ( CacheBuilderSpec spec , String key , String value ) { checkArgument ( value != null && !value.isEmpty ( ) , " value of key %s omitted " , key ) ; try { parseLong ( spec , Long.parseLong ( value ) ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( format ( " key %s value set to %s , must be integer " , key , value ) , e ) ; } }
protected void parseInteger ( CacheBuilderSpec spec , int value ) { checkArgument ( spec.initialCapacity == null , " initial capacity was already set to " , spec.initialCapacity ) ; spec.initialCapacity = value ; }
protected void parseLong ( CacheBuilderSpec spec , long value ) { checkArgument ( spec.maximumSize == null , " maximum size was already set to " , spec.maximumSize ) ; checkArgument ( spec.maximumWeight == null , " maximum weight was already set to " , spec.maximumWeight ) ; spec.maximumSize = value ; }
protected void parseLong ( CacheBuilderSpec spec , long value ) { checkArgument ( spec.maximumWeight == null , " maximum weight was already set to " , spec.maximumWeight ) ; checkArgument ( spec.maximumSize == null , " maximum size was already set to " , spec.maximumSize ) ; spec.maximumWeight = value ; }
protected void parseInteger ( CacheBuilderSpec spec , int value ) { checkArgument ( spec.concurrencyLevel == null , " concurrency level was already set to " , spec.concurrencyLevel ) ; spec.concurrencyLevel = value ; }
public void parse ( CacheBuilderSpec spec , String key , @Nullable String value ) { checkArgument ( value == null , " key %s does not take values " , key ) ; checkArgument ( spec.keyStrength == null , " %s was already set to %s " , key , spec.keyStrength ) ; spec.keyStrength = strength ; }
public void parse ( CacheBuilderSpec spec , String key , @Nullable String value ) { checkArgument ( value == null , " key %s does not take values " , key ) ; checkArgument ( spec.valueStrength == null , " %s was already set to %s " , key , spec.valueStrength ) ; spec.valueStrength = strength ; }
public void parse ( CacheBuilderSpec spec , String key , @Nullable String value ) { checkArgument ( value == null , " recordStats does not take values " ) ; checkArgument ( spec.recordStats == null , " recordStats already set " ) ; spec.recordStats = true ; }
protected void parseDuration ( CacheBuilderSpec spec , long duration , TimeUnit unit ) { checkArgument ( spec.accessExpirationTimeUnit == null , " expireAfterAccess already set " ) ; spec.accessExpirationDuration = duration ; spec.accessExpirationTimeUnit = unit ; }
protected void parseDuration ( CacheBuilderSpec spec , long duration , TimeUnit unit ) { checkArgument ( spec.writeExpirationTimeUnit == null , " expireAfterWrite already set " ) ; spec.writeExpirationDuration = duration ; spec.writeExpirationTimeUnit = unit ; }
protected void parseDuration ( CacheBuilderSpec spec , long duration , TimeUnit unit ) { checkArgument ( spec.refreshTimeUnit == null , " refreshAfterWrite already set " ) ; spec.refreshDuration = duration ; spec.refreshTimeUnit = unit ; }
private static String format ( String format , Object... args ) { return String.format ( Locale.ROOT , format , args ) ; }
public ListenableFuture < V > reload ( K key , V oldValue ) throws Exception { checkNotNull ( key ) ; checkNotNull ( oldValue ) ; return Futures.immediateFuture ( load ( key ) ) ; }
public Map < K , V > loadAll ( Iterable < ? extends K > keys ) throws Exception { throw new UnsupportedLoadingOperationException ( ) ; }
public static < K , V > CacheLoader < K , V > from ( Function < K , V > function ) { return new FunctionToCacheLoader < > ( function ) ; }
public static < V > CacheLoader < Object , V > from ( Supplier < V > supplier ) { return new SupplierToCacheLoader < V > ( supplier ) ; }
public V load ( K key ) { return computingFunction.apply ( checkNotNull ( key ) ) ; }
public V load ( K key ) throws Exception { return loader.load ( key ) ; }
public V call ( ) throws Exception { return loader.reload ( key , oldValue ) .get ( ) ; }
public Map < K , V > loadAll ( Iterable < ? extends K > keys ) throws Exception { return loader.loadAll ( keys ) ; }
public V load ( Object key ) { checkNotNull ( key ) ; return computingSupplier.get ( ) ; }
public long requestCount ( ) { return saturatedAdd ( hitCount , missCount ) ; }
public long hitCount ( ) { return hitCount ; }
public double hitRate ( ) { long requestCount = requestCount ( ) ; return ( requestCount == 0 ) ? 1.0 : ( double ) hitCount / requestCount ; }
public long missCount ( ) { return missCount ; }
public double missRate ( ) { long requestCount = requestCount ( ) ; return ( requestCount == 0 ) ? 0.0 : ( double ) missCount / requestCount ; }
public long loadCount ( ) { return saturatedAdd ( loadSuccessCount , loadExceptionCount ) ; }
public long loadSuccessCount ( ) { return loadSuccessCount ; }
public long loadExceptionCount ( ) { return loadExceptionCount ; }
public double loadExceptionRate ( ) { long totalLoadCount = saturatedAdd ( loadSuccessCount , loadExceptionCount ) ; return ( totalLoadCount == 0 ) ? 0.0 : ( double ) loadExceptionCount / totalLoadCount ; }
public long totalLoadTime ( ) { return totalLoadTime ; }
public double averageLoadPenalty ( ) { long totalLoadCount = saturatedAdd ( loadSuccessCount , loadExceptionCount ) ; return ( totalLoadCount == 0 ) ? 0.0 : ( double ) totalLoadTime / totalLoadCount ; }
public long evictionCount ( ) { return evictionCount ; }
public CacheStats minus ( CacheStats other ) { return new CacheStats ( Math.max ( 0 , saturatedSubtract ( hitCount , other.hitCount ) ) , Math.max ( 0 , saturatedSubtract ( missCount , other.missCount ) ) , Math.max ( 0 , saturatedSubtract ( loadSuccessCount , other.loadSuccessCount ) ) , Math.max ( 0 , saturatedSubtract ( loadExceptionCount , other.loadExceptionCount ) ) , Math.max ( 0 , saturatedSubtract ( totalLoadTime , other.totalLoadTime ) ) , Math.max ( 0 , saturatedSubtract ( evictionCount , other.evictionCount ) ) ) ; }
public CacheStats plus ( CacheStats other ) { return new CacheStats ( saturatedAdd ( hitCount , other.hitCount ) , saturatedAdd ( missCount , other.missCount ) , saturatedAdd ( loadSuccessCount , other.loadSuccessCount ) , saturatedAdd ( loadExceptionCount , other.loadExceptionCount ) , saturatedAdd ( totalLoadTime , other.totalLoadTime ) , saturatedAdd ( evictionCount , other.evictionCount ) ) ; }
public V getIfPresent ( Object key ) { return delegate ( ) .getIfPresent ( key ) ; }
public V get ( K key , Callable < ? extends V > valueLoader ) throws ExecutionException { return delegate ( ) .get ( key , valueLoader ) ; }
public ImmutableMap < K , V > getAllPresent ( Iterable < ? > keys ) { return delegate ( ) .getAllPresent ( keys ) ; }
public void put ( K key , V value ) { delegate ( ) .put ( key , value ) ; }
public void putAll ( Map < ? extends K , ? extends V > m ) { delegate ( ) .putAll ( m ) ; }
public void invalidate ( Object key ) { delegate ( ) .invalidate ( key ) ; }
public void invalidateAll ( Iterable < ? > keys ) { delegate ( ) .invalidateAll ( keys ) ; }
public void invalidateAll ( ) { delegate ( ) .invalidateAll ( ) ; }
public long size ( ) { return delegate ( ) .size ( ) ; }
public CacheStats stats ( ) { return delegate ( ) .stats ( ) ; }
public ConcurrentMap < K , V > asMap ( ) { return delegate ( ) .asMap ( ) ; }
public void cleanUp ( ) { delegate ( ) .cleanUp ( ) ; }
protected final Cache < K , V > delegate ( ) { return delegate ; }
public V get ( K key ) throws ExecutionException { return delegate ( ) .get ( key ) ; }
public V getUnchecked ( K key ) { return delegate ( ) .getUnchecked ( key ) ; }
public ImmutableMap < K , V > getAll ( Iterable < ? extends K > keys ) throws ExecutionException { return delegate ( ) .getAll ( keys ) ; }
public V apply ( K key ) { return delegate ( ) .apply ( key ) ; }
public void refresh ( K key ) { delegate ( ) .refresh ( key ) ; }
protected final LoadingCache < K , V > delegate ( ) { return delegate ; }
boolean evictsBySize ( ) { return maxWeight > = 0 ; }
boolean customWeigher ( ) { return weigher != OneWeigher.INSTANCE ; }
boolean expires ( ) { return expiresAfterWrite ( ) || expiresAfterAccess ( ) ; }
boolean expiresAfterWrite ( ) { return expireAfterWriteNanos > 0 ; }
boolean expiresAfterAccess ( ) { return expireAfterAccessNanos > 0 ; }
boolean refreshes ( ) { return refreshNanos > 0 ; }
boolean usesAccessQueue ( ) { return expiresAfterAccess ( ) || evictsBySize ( ) ; }
boolean usesWriteQueue ( ) { return expiresAfterWrite ( ) ; }
boolean recordsWrite ( ) { return expiresAfterWrite ( ) || refreshes ( ) ; }
boolean recordsAccess ( ) { return expiresAfterAccess ( ) ; }
boolean recordsTime ( ) { return recordsWrite ( ) || recordsAccess ( ) ; }
boolean usesWriteEntries ( ) { return usesWriteQueue ( ) || recordsWrite ( ) ; }
boolean usesAccessEntries ( ) { return usesAccessQueue ( ) || recordsAccess ( ) ; }
boolean usesKeyReferences ( ) { return keyStrength != Strength.STRONG ; }
boolean usesValueReferences ( ) { return valueStrength != Strength.STRONG ; }
Equivalence < Object > defaultEquivalence ( ) { return Equivalence.equals ( ) ; }
Equivalence < Object > defaultEquivalence ( ) { return Equivalence.identity ( ) ; }
static EntryFactory getFactory ( Strength keyStrength , boolean usesAccessQueue , boolean usesWriteQueue ) { int flags = ( ( keyStrength == Strength.WEAK ) ? WEAK_MASK : 0 ) | ( usesAccessQueue ? ACCESS_MASK : 0 ) | ( usesWriteQueue ? WRITE_MASK : 0 ) ; return factories[flags] ; }
 < K , V > void copyAccessEntry ( ReferenceEntry < K , V > original , ReferenceEntry < K , V > newEntry ) { newEntry.setAccessTime ( original.getAccessTime ( ) ) ; connectAccessOrder ( original.getPreviousInAccessQueue ( ) , newEntry ) ; connectAccessOrder ( newEntry , original.getNextInAccessQueue ( ) ) ; nullifyAccessOrder ( original ) ; }
 < K , V > void copyWriteEntry ( ReferenceEntry < K , V > original , ReferenceEntry < K , V > newEntry ) { newEntry.setWriteTime ( original.getWriteTime ( ) ) ; connectWriteOrder ( original.getPreviousInWriteQueue ( ) , newEntry ) ; connectWriteOrder ( newEntry , original.getNextInWriteQueue ( ) ) ; nullifyWriteOrder ( original ) ; }
public int getWeight ( ) { return 0 ; }
public boolean isLoading ( ) { return false ; }
public boolean isActive ( ) { return false ; }
static < K , V > ValueReference < K , V > unset ( ) { return ( ValueReference < K , V > ) UNSET ; }
public int getHash ( ) { return 0 ; }
public long getAccessTime ( ) { return 0 ; }
public ReferenceEntry < Object , Object > getNextInAccessQueue ( ) { return this ; }
public ReferenceEntry < Object , Object > getPreviousInAccessQueue ( ) { return this ; }
public long getWriteTime ( ) { return 0 ; }
public ReferenceEntry < Object , Object > getNextInWriteQueue ( ) { return this ; }
public ReferenceEntry < Object , Object > getPreviousInWriteQueue ( ) { return this ; }
static < K , V > ReferenceEntry < K , V > nullEntry ( ) { return ( ReferenceEntry < K , V > ) NullEntry.INSTANCE ; }
public boolean offer ( Object o ) { return true ; }
public int size ( ) { return 0 ; }
public Iterator < Object > iterator ( ) { return ImmutableSet.of ( ) .iterator ( ) ; }
static < E > Queue < E > discardingQueue ( ) { return ( Queue ) DISCARDING_QUEUE ; }
public K getKey ( ) { return this.key ; }
public ValueReference < K , V > getValueReference ( ) { return valueReference ; }
public void setValueReference ( ValueReference < K , V > valueReference ) { this.valueReference = valueReference ; }
public int getHash ( ) { return hash ; }
public ReferenceEntry < K , V > getNext ( ) { return next ; }
public long getAccessTime ( ) { return accessTime ; }
public void setAccessTime ( long time ) { this.accessTime = time ; }
public ReferenceEntry < K , V > getNextInAccessQueue ( ) { return nextAccess ; }
public void setNextInAccessQueue ( ReferenceEntry < K , V > next ) { this.nextAccess = next ; }
public ReferenceEntry < K , V > getPreviousInAccessQueue ( ) { return previousAccess ; }
public void setPreviousInAccessQueue ( ReferenceEntry < K , V > previous ) { this.previousAccess = previous ; }
public long getWriteTime ( ) { return writeTime ; }
public void setWriteTime ( long time ) { this.writeTime = time ; }
public ReferenceEntry < K , V > getNextInWriteQueue ( ) { return nextWrite ; }
public void setNextInWriteQueue ( ReferenceEntry < K , V > next ) { this.nextWrite = next ; }
public ReferenceEntry < K , V > getPreviousInWriteQueue ( ) { return previousWrite ; }
public void setPreviousInWriteQueue ( ReferenceEntry < K , V > previous ) { this.previousWrite = previous ; }
public K getKey ( ) { return get ( ) ; }
public int getWeight ( ) { return 1 ; }
public ReferenceEntry < K , V > getEntry ( ) { return entry ; }
public ValueReference < K , V > copyFor ( ReferenceQueue < V > queue , V value , ReferenceEntry < K , V > entry ) { return new WeakValueReference < > ( queue , value , entry ) ; }